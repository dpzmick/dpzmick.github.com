<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>"Garbage collection" for Rust Arc Pointers &#8211; dpzmick.com</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Cleaning up after yourself in realtime">
    <meta name="author" content="David Zmick">
    
    <link rel="canonical" href="http://dpzmick.com/2016-11-19-rust-arc-gc-realtime/">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css" type="text/css">

    <!-- MathJax config -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax:        ["input/TeX", "output/HTML-CSS"],
        tex2jax:    {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
        },
        "HTML-CSS": {
             availableFonts:
             ["TeX"]
        }
    });
    </script>

    <!-- Fonts -->
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
      <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content=""Garbage collection" for Rust Arc Pointers">
    <meta property="og:description" content="Just some dude's blog">
    <meta property="og:url" content="http://dpzmick.com/2016-11-19-rust-arc-gc-realtime/">
    <meta property="og:site_name" content="dpzmick.com">

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
</head>

<body class="">
  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://dpzmick.com" class="site-title">dpzmick.com</a>
      <nav class="site-nav right">
        <a href="/about/">About</a>
<a href="/series/">Blog Series</a>
<a href="http://dpzmick.com/resume/resume.pdf">Resume</a>

      </nav>
      <div class="clearfix"></div>
      
        <div class="social-icons">
  <div class="left">
    
      <a class="fa fa-github" href="https://github.com/dpzmick"></a>
    
    
    <a class="fa fa-rss" href="/feed.xml"></a>
    
    

    <!--
    
    <a class="fa fa-envelope" href="/contact"></a>
    
    -->

    
      <a class="fa fa-linkedin" href="https://www.linkedin.com/in/dpzmick"></a>
    
  </div>
  <div class="right">
    
    
    
  </div>
</div>
<div class="clearfix"></div>

      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        


<div class="post-header mb2">
  <h1>"Garbage collection" for Rust Arc Pointers</h1>
  <span class="post-meta"></span><br>
  
  <span class="post-meta small">40 minute read</span>
</div>

<article class="post-content">
  <p>Recently, I’ve been working on a synthesizer (the kind that makes sounds) in Rust.
This post will be the first of many (see my <a href="/series/">Blog Series</a> page)</p>

<p>While trying to figure out how to safely send messages between a realtime audio processing thread and other threads (ui thread, disk I/O thread, etc), I stumbled across an excellent talk.
In the talk, the speaker uses <code class="highlighter-rouge">std::shared_ptr</code> and a lightweight “garbage collector” to easily send messages between threads.
The talk is <a href="https://www.youtube.com/watch?v=boPEO2auJj4">on youtube</a>, I highly recommend watching it.
This post will first explain why such a thing is useful (as does the talk), and how we can do the same thing in Rust.</p>

<h1 id="digital-audio">Digital audio</h1>
<p>Before we can talk about the Rust stuff, we need to understand a bit about digital audio.</p>

<p>To generate audio, audio software sends some digital audio signals to the audio card.
Digital audio signals are just lists of floating point (decimal) numbers.
Think of these numbers as “sound pressure” over time (see <a href="https://docs.cycling74.com/max5/tutorials/msp-tut/mspdigitalaudio.html">this page</a> for more)</p>

<p>Because sound is continuous, we can’t record every possibly value.
Instead, we take measurements of the sound pressure values at some evenly spaced interval.
For CD quality audio, we take 44100 samples per second, or, one sample every 23ish microseconds.
We might sample a sine wave like this (from Wikipedia):</p>

<p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/b/bf/Pcm.svg/500px-Pcm.svg.png" alt="Samples" /></p>

<p>The audio card turns these lists of samples into some “real-world” audio, which is then played through the speakers.</p>

<h2 id="types-of-audio-software">Types of audio software</h2>
<p>Next let’s think about a few different kinds of audio software (this list is by no means complete):</p>

<ol>
  <li>Media players (your browser, whatever you listen to music with, a game, etc)</li>
  <li>Software instruments (think of a virtual piano)</li>
  <li>Audio plugins (an equalizer in a music player, effects like distortion and compression)</li>
  <li>Software audio systems</li>
</ol>

<p>Media players are pretty self explanatory, but the others might need some explanation.
Next on the list is “Software instruments.”
These are just pieces of software that can be used to generate sounds.
They are played with external keyboards, or “programmed” with cool user interfaces.</p>

<p><img src="/img/sound/reason_drums.jpg" alt="Drum machine" />
<em>Drum machine in some audio software</em></p>

<p>Next up are audio plugins.
These are pieces of software which take audio as input, transform it in some way, then output the transformed audio.
For example, a graphical equalizer can adjust the volume of different frequency ranges (make the bass louder, make the treble quieter):</p>

<p><img src="/img/sound/itunes_eq.jpg" alt="equalizer" /></p>

<p>Finally, we come to what I’m calling a software audio system.
Because there is only one sound card on your system, any audio you are playing on your computer must be mixed together, then sent to the audio card.
On windows, using the default audio system, I can mix audio with this little mixer thing:</p>

<p><img src="/img/sound/win_mixer.png" alt="windows mixer" /></p>

<p><a href="http://www.jackaudio.org/">Some audio systems</a> may also be able to send audio between applications, send <a href="https://en.wikipedia.org/wiki/MIDI">MIDI</a> signals, keep audio applications in sync, and perform many other tasks.</p>

<p>The software audio system provides a library which other applications use to produce audio.</p>

<h1 id="audio-system-details">Audio system details</h1>
<p>Most software audio systems (as far as I know) tend to work the same way.
There is a realtime thread that generates samples and a bunch of other threads that deal with everything else.
The audio thread is usually set up by the audio system’s library.
The library calls a user provided callback function to get the samples it needs to deliver to the audio card.</p>

<h2 id="how-fast-is-realtime">How fast is realtime?</h2>
<p>In the previous section, I claimed that, at 44.1 kHz (the standard CD sample rate), we need to take one audio sample approximately every 23 microseconds.
23 microseconds seems pretty quick, but 192 kHz, a sample must be taken about every 5 microseconds (192 kHz is becoming a bit of an industry standard)!</p>

<p>At these speeds, it would not be possible for the audio system to call our callback function to get every individual sample.
Instead, the audio library system ask us for larger batches of samples.
If we simplify the real world a bit, we can approximate how often our callback function will be called.
Here’s a table comparing batch size to the time between callback function calls (all times in milliseconds):</p>

<table>
  <thead>
    <tr>
      <th>Batch Size</th>
      <th>Time between calls @ 44.1 kHz (millis)</th>
      <th>Time between calls @ 192 kHz (millis)</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <td>64</td>
      <td>1.45</td>
      <td>0.33</td>
    </tr>
    <tr>
      <td>128</td>
      <td>2.90</td>
      <td>0.67</td>
    </tr>
    <tr>
      <td>256</td>
      <td>5.80</td>
      <td>1.33</td>
    </tr>
    <tr>
      <td>512</td>
      <td>11.61</td>
      <td>2.67</td>
    </tr>
    <tr>
      <td>1024</td>
      <td>23.22</td>
      <td>5.33</td>
    </tr>
    <tr>
      <td>2048</td>
      <td>46.44</td>
      <td>10.67</td>
    </tr>
    <tr>
      <td>4096</td>
      <td>92.88</td>
      <td>21.33</td>
    </tr>
  </tbody>
</table>

<p>There are many complicated trade offs between sample rate/and batch size, so I don’t want to get into them now.
You can read <a href="http://www.penguinproducer.com/Blog/2011/10/balancing-performance-and-reliability-in-jack/">this</a> for a bit more information.
Long story short, use the smallest batch size your computer can handle.</p>

<p>As an audio application developer, we should make sure that our code runs as quickly as possible, even if we have a whole 5 milliseconds to run.
The time we spend is time other audio applications cannot use.
So, even if we theoretically have 5 milliseconds to run, using the entire 5 milliseconds can slow everyone else down.</p>

<h2 id="time-keeps-on-ticking">Time keeps on ticking</h2>
<p>If our callback function fails to generate samples quickly enough (or uses up all of the CPU time), the audio system will produce crackles, pops, and bad sounds.
We call these buffer underruns (or xruns).
<strong>Avoiding buffer underruns must be our top priority!</strong></p>

<p>Everything we do in our callback function must <em>always</em> complete quickly and in a very predictable amount of time.
Unfortunately, this constraint eliminates many things of things we often take for granted, including:</p>

<ul>
  <li>Synchronization through locking</li>
  <li>Operations with high worst case runtime</li>
  <li>Memory allocation with standard allocators</li>
</ul>

<p>First, we can’t use locks or semaphores or conditional variables or any of those kinds of things inside of our realtime callback function.
If one of our other threads is holding the lock, it might not let go soon enough for us to generate our samples on time!
If you try to make sure you locks will always be released quickly, the scheduler might step in and ruin your plans (this is called <a href="https://en.wikipedia.org/wiki/Priority_inversion">Priority Inversion</a>).
There are some cases in which it <em>might</em> be okay to use locks, but, in general, it is a good idea to avoid them.</p>

<p>Second, we want to avoid operations which have a high worst case runtime.
This can be tricky because some things with bad worst case runtime things have a reasonable <a href="https://en.wikipedia.org/wiki/Amortized_analysis">amortized</a> runtime.
The canonical example of this is a <a href="https://en.wikipedia.org/wiki/Dynamic_array">dynamic array</a>.
A dynamic array can be inserted into very quickly most of the time, but every so often if must reallocate itself and copy all of its data somewhere else.
For a large array, this expensive copy might cause us to miss our deadline every once and a while.
Fortunately, for some data structures, we can push these worst case costs around and make the operations realtime safe (see <a href="https://en.wikipedia.org/wiki/Hash_table#Dynamic_resizing">Incremental resizing</a>).</p>

<p>Finally, memory allocation with standard library allocators can cause problems.
Memory allocators are usually thread safe, which usually means that the are locking something.
Additionally, allocation algorithms rarely make any time guarantees; the algorithms they use can have very poor worst case runtimes.
Standard library allocators break both of our other rules!
Luckily, we can still perform dynamic memory allocation if we use <a href="http://www.gii.upv.es/tlsf/">specially designed allocators</a> or <a href="https://github.com/supercollider/supercollider/blob/master/common/SC_AllocPool.h">some pool allocators</a> which do not violate our realtime constraints.</p>

<p>I’ve glossed over many, many details in this section, but, the <a href="https://www.youtube.com/watch?v=boPEO2auJj4">cppcon video</a>, and <a href="http://www.rossbencina.com/code/real-time-audio-programming-101-time-waits-for-nothing">this excellent post</a> both go into much more detail, if you are interested (and why wouldn’t you be??).</p>

<h1 id="messaging-between-threads">Messaging between threads</h1>
<p>Suppose we are developing a very simple synthesizer which produces sounds when keys are pressed on a MIDI keyboard.
The audio library we are using delivers all keyboard key presses to the realtime audio callback function at the appropriate times.
The callback function uses a precomputed list of samples to generate sounds when it is told to.
To modify the properties of the sounds that are produced, the user edits the synthesizer settings with a user interface.</p>

<p>The fun starts when we think about how to update the precomputed list of samples when the user changes some properties of sound we are currently generating.
It would be painful (and incorrect) to attempt to handle UI events in the realtime thread, so we will run a UI thread (to handle UI events) and, of course, the realtime audio thread.
The UI thread will not be a realtime thread!
So, whenever the UI thread handles an event which changes the synth settings, the UI thread needs to compute the sample list, then communicate the sample list to the realtime thread.</p>

<p>We can’t read and write to the list of samples are the same time (that would be a data race!), so we need some way to control access to the list of samples.
The most obvious way to solve this is, then surround all access to the list of samples with a <code class="highlighter-rouge">mutex</code>.
With the <code class="highlighter-rouge">mutex</code>, each thread has exclusive access to the set of samples when it needs to read or write to them, so the threads can never interfere with each other.</p>

<p>Unless you have some aversion to locks (you prefer channels or something), this is probably how most of us would write the application.
Unfortunately, we shouldn’t use locks in our realtime thread!</p>

<p>There are many, many solutions to this problem.
I will discuss some others in future posts.
For now, we will just look at one possible solution and discuss some of the tradeoffs we must make.
In a later post, I will compare a different options (with benchmarks), but for this post, we will just write a small example and <em>think</em> really hard about it (treat it more like a though experiment).</p>

<p>And, as promised, here is a list of really interesting things you can read to learn more:</p>
<ul>
  <li><a href="http://www.cs.cmu.edu/~rbd/doc/icmc2005workshop/real-time-systems-concepts-design-patterns.pdf">Overview of Design Patterns for Real-Time Computer Music Systems</a></li>
  <li><a href="http://supercolliderbook.net/rossbencinach26.pdf">SuperCollider implementation details</a> from the <a href="http://supercolliderbook.net/">SuperCollider book</a></li>
  <li><a href="http://tim.klingt.org/publications/tim_blechmann_supernova.pdf">Supernova for SuperCollider</a> a Masters thesis discussing some of these issues</li>
</ul>

<h1 id="reference-counted-garbage-collector">Reference counted garbage collector</h1>
<p>Finally, we can talk about the (intended) subject of this post.
My objective is to send a message containing some samples to the realtime thread.
I think a lock free queue is a pretty good way to send messages between threads, and I like to think <a href="https://en.wikipedia.org/wiki/Communicating_sequential_processes">CSP</a> style.
I would like to let this message live somewhere on the heap, so that I do not need to copy it multiple times.
If the message lives on the heap, we must ensure two things:</p>

<ol>
  <li>It must be freed at some point</li>
  <li>Multiple threads do not/can not write to the memory at the same time</li>
</ol>

<p>The specific lock-free queue that we chose to use needs to have a few properties:</p>
<ul>
  <li>Must be truly lock free</li>
  <li>Must be able to preallocate all of its nodes (cant’t allocate and free a node object on a push and pull)</li>
</ul>

<p>For the sake of these examples, let’s assume that the built in Rust <a href="https://doc.rust-lang.org/std/sync/mpsc/index.html">mpsc channel</a> is an appropriate lock free queue.
It will be pretty easy to swap this with something different later, and, if we use the standard library, all of the examples will easily run in the rust playground.
We are also going to fake a bunch of the details of the audio library.</p>

<h2 id="fake-audio-library">Fake audio library</h2>
<p>Rust playground link: <a href="https://is.gd/Qe1YjZ">https://is.gd/Qe1YjZ</a></p>

<p>We don’t need to walk through this code, it just makes some threads and calls some empty functions.
The important bits are the <code class="highlighter-rouge">RealtimeThread::realtime_callback</code> function and the <code class="highlighter-rouge">UIThread::run</code> functions.
In this example, the realtime callback function says “I’m done!” to let the realtime thread shutdown, and the UI thread does nothing at all.</p>

<p>Here’s the code:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>

<span class="cp">#[derive(PartialEq)]</span>
<span class="k">enum</span> <span class="n">CallbackStatus</span> <span class="p">{</span>
    <span class="n">Continue</span><span class="p">,</span>
    <span class="n">Shutdown</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// "library" code starts here</span>
<span class="k">type</span> <span class="n">Samples</span> <span class="o">=</span> <span class="p">[</span><span class="nb">f32</span><span class="p">;</span> <span class="mi">64</span><span class="p">];</span>

<span class="k">fn</span> <span class="nf">run_threads</span><span class="p">(</span><span class="k">mut</span> <span class="n">rt</span><span class="p">:</span> <span class="n">RealtimeThread</span><span class="p">,</span> <span class="k">mut</span> <span class="n">ui</span><span class="p">:</span> <span class="n">UIThread</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"[ui] thread started"</span><span class="p">);</span>
        <span class="n">ui</span><span class="nf">.run</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"[ui] thread shutting down"</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"[realtime] thread started"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">;</span> <span class="mi">64</span><span class="p">];</span>
    <span class="k">while</span> <span class="n">rt</span><span class="nf">.realtime_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">output</span><span class="p">)</span> <span class="o">!=</span> <span class="nn">CallbackStatus</span><span class="p">::</span><span class="n">Shutdown</span> <span class="p">{</span> <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"[realtime] thread shutting down"</span><span class="p">);</span>

    <span class="n">join_handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
<span class="c">// end of "library" code</span>

<span class="c">/// A struct containing the realtime callback and all data owned by the realtime thread</span>
<span class="k">struct</span> <span class="n">RealtimeThread</span> <span class="p">{</span>
    <span class="c">// some members here eventually</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RealtimeThread</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span> <span class="n">RealtimeThread</span><span class="p">{}</span> <span class="p">}</span>

    <span class="c">/// realtime callback, called to get the list of samples</span>
    <span class="k">fn</span> <span class="nf">realtime_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">output_samples</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Samples</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CallbackStatus</span> <span class="p">{</span>
        <span class="nn">CallbackStatus</span><span class="p">::</span><span class="n">Shutdown</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">/// A struct which runs the UI thread and contains all of the data owned by the UI thread</span>
<span class="k">struct</span> <span class="n">UIThread</span> <span class="p">{</span>
    <span class="c">// some members here eventually</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">UIThread</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span> <span class="n">UIThread</span><span class="p">{}</span> <span class="p">}</span>

    <span class="c">/// All of the UI thread code</span>
    <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// do nothing!</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rt</span> <span class="o">=</span> <span class="nn">RealtimeThread</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ui</span> <span class="o">=</span> <span class="nn">UIThread</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nf">run_threads</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Output (one of many possible):</p>

<div class="highlighter-rouge"><pre class="highlight"><code>[realtime] thread started
[realtime] thread shutting down
[ui] thread started
[ui] thread shutting down
</code></pre>
</div>

<h2 id="sending-arcs-between-threads">Sending Arcs between threads</h2>
<p>Now that we have an “audio library,” lets try to make some messages and pass them between threads.
I’m going to jump right into the “garbage collector” solution here.
Other solutions will be discussed elsewhere.</p>

<p>The <code class="highlighter-rouge">RealtimeThread</code> struct will need to hold on to a list of samples which it will use to populate the <code class="highlighter-rouge">output</code> samples every time the callback is called.
We want these samples to be heap allocated and reference counted, so we wrap them in an <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code class="highlighter-rouge">Arc</code></a>.
Finally, we want to leave the samples uninitialized until the UI thread sends us some, so we wrap the <code class="highlighter-rouge">Arc&lt;Samples&gt;</code> in an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code class="highlighter-rouge">Option</code></a>.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">RealtimeThread</span> <span class="p">{</span>
    <span class="n">current_samples</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Samples</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Now that the realtime thread has a list of samples, we can fill in a bit of the body of the realtime callback function:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">realtime_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">output_samples</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Samples</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CallbackStatus</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.current_samples</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">samples</span><span class="p">|</span> <span class="p">{</span>
        <span class="c">// samples: &amp;Arc&lt;[f32; 64]&gt;</span>
        <span class="n">output_samples</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">samples</span><span class="nf">.as_ref</span><span class="p">())</span>
    <span class="p">});</span>

    <span class="nn">CallbackStatus</span><span class="p">::</span><span class="n">Continue</span>
<span class="p">}</span>
</code></pre>
</div>

<p>The function <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.copy_from_slice"><code class="highlighter-rouge">copy_from_slice</code></a> will <code class="highlighter-rouge">memcpy</code> the samples we are holding onto into the buffer provided by the audio library.</p>

<p>Moving over to the UI thread, first, we need to be able to compute a list of samples to compute.
Here is a function that computes 64 samples along a sine wave with a given peak amplitude:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">/// computes the samples needed for on cycle of a sine wave</span>
<span class="c">/// the volume parameter sets the audible volume of sound produced</span>
<span class="k">fn</span> <span class="nf">compute_samples</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">volume</span><span class="p">:</span> <span class="nb">f32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Samples</span> <span class="p">{</span>
    <span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="n">volume</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="n">volume</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">);</span>

    <span class="c">// we need to populate 64 samples with 1 cycle of a sine wave (arbitrary choice)</span>
    <span class="k">let</span> <span class="n">constant_factor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="err">/</span><span class="mf">64.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nn">f32</span><span class="p">::</span><span class="nn">consts</span><span class="p">::</span><span class="n">PI</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">samples</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">;</span> <span class="mi">64</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="err">..</span><span class="mi">64</span> <span class="p">{</span>
        <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">constant_factor</span> <span class="o">*</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">f32</span><span class="p">)</span><span class="nf">.sin</span><span class="p">()</span> <span class="o">*</span> <span class="n">volume</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">samples</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Notice that it returns the list of samples by value.
Have no fear, <a href="https://en.wikipedia.org/wiki/Return_value_optimization">return value optimization</a> is here!
I don’t actually know if Rust will perform this optimization (TODO VERIFY THIS), but it doesn’t really matter for this example.
If we do end up copying the samples, it doesn’t matter that much.
Even if the copy is slow, we will be performing the copy on the UI thread, where we can afford to be a bit slower.</p>

<p>The UI thread will generate some fake events, and compute samples for these events:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">/// All of the UI thread code</span>
<span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// create 10 "ui events"</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="err">..</span><span class="mi">10</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">f32</span> <span class="err">/</span> <span class="mf">10.0</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">samples</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="nf">.compute_samples</span><span class="p">(</span><span class="n">volume</span><span class="p">));</span>

        <span class="c">// send the samples to the other thread</span>
    <span class="p">}</span>

    <span class="c">// tell the other thread to shutdown</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Now that we’ve done all of that, we need to send the samples between threads.
We need a message type.
Messages from the UI thread will be either a new list of samples or a request to shutdown.
Since we are storing the samples as an <code class="highlighter-rouge">Arc</code>, we will send them to the realtime thread as an <code class="highlighter-rouge">Arc</code>.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Message</span> <span class="p">{</span>
    <span class="nf">NewSamples</span><span class="p">(</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Samples</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="n">Shutdown</span><span class="p">,</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Remember when I said that we would make a bunch of assumptions about the <code class="highlighter-rouge">mpsc</code> queues?
Here’s where I’m going to do that.
We are going to assume that this queue follows all the properties we need a realtime queue to follow.
For a quick reminder, those are:</p>
<ul>
  <li>No locks</li>
  <li>No allocation (or deallocation) in the realtime thread.</li>
</ul>

<p>To send messages between the threads, we will use <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.sync_channel.html"><code class="highlighter-rouge">mpcs::sync_channel</code></a> to create a synchronous channel (queue).
This channel is bounded, so a sender cannot add a new message to the queue unless there is currently space available.
We are going to set the buffer size to zero.
This means that the channel will not buffer any messages.
From <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.sync_channel.html">the docs</a>:</p>

<blockquote>
  <p>Note that a buffer size of 0 is valid, in which case this [channel] becomes “rendezvous channel” where each send will not return until a recv is paired with it.</p>
</blockquote>

<p>To create this queue, first we need to add some code to <code class="highlighter-rouge">main</code> to create the queues:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nf">sync_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">rt</span> <span class="o">=</span> <span class="nn">RealtimeThread</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">ui</span> <span class="o">=</span> <span class="nn">UIThread</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">tx</span><span class="p">);</span>
    <span class="nf">run_threads</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Then, modify both thread structs and both <code class="highlighter-rouge">new</code> functions.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">RealtimeThread</span> <span class="p">{</span>
    <span class="n">current_samples</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Samples</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">incoming</span><span class="p">:</span>        <span class="nn">mpsc</span><span class="p">::</span><span class="n">Receiver</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// ...</span>

<span class="k">struct</span> <span class="n">UIThread</span> <span class="p">{</span>
    <span class="n">outgoing</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">SyncSender</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// changes to new omitted</span>
</code></pre>
</div>

<p>Now, let’s get our threads sending messages, starting with the UI thread.
In both cases, if the send fails, something has gone horribly wrong, so its fine to <code class="highlighter-rouge">unwrap</code> the result of these sends.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">/// All of the UI thread code</span>
<span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// create 10 "ui events"</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="err">..</span><span class="mi">10</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">f32</span> <span class="err">/</span> <span class="mf">10.0</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">samples</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="nf">.compute_samples</span><span class="p">(</span><span class="n">volume</span><span class="p">));</span>

        <span class="c">// send the samples to the other thread</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"[ui] sending new samples. Second sample: {}"</span><span class="p">,</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">self</span><span class="py">.outgoing</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Message</span><span class="p">::</span><span class="nf">NewSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c">// tell the other thread to shutdown</span>
    <span class="k">self</span><span class="py">.outgoing</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Message</span><span class="p">::</span><span class="n">Shutdown</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre>
</div>

<p>In the realtime thread, we check if there is a new message on the queue.
If there is, handle it.
If not, just keep doing what we were doing.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">/// realtime callback, called to get the list of samples</span>
<span class="k">fn</span> <span class="nf">realtime_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">output_samples</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Samples</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CallbackStatus</span> <span class="p">{</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.incoming</span><span class="nf">.try_recv</span><span class="p">()</span> <span class="p">{</span>
        <span class="c">// we've received a messaged</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">message</span> <span class="p">{</span>
            <span class="nn">Message</span><span class="p">::</span><span class="nf">NewSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"[realtime] received new samples. Second sample: {}"</span><span class="p">,</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="k">self</span><span class="py">.current_samples</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            <span class="p">},</span>

            <span class="nn">Message</span><span class="p">::</span><span class="n">Shutdown</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nn">CallbackStatus</span><span class="p">::</span><span class="n">Shutdown</span>
        <span class="p">},</span>

        <span class="c">// if we failed to receive anything, just keep sending samples</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">()</span>
    <span class="p">}</span>

    <span class="c">// copy our current samples into the output buffer</span>
    <span class="k">self</span><span class="py">.current_samples</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">samples</span><span class="p">|</span> <span class="p">{</span>
        <span class="c">// samples: &amp;Arc&lt;[f32; 64&gt;</span>
        <span class="n">output_samples</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">samples</span><span class="nf">.as_ref</span><span class="p">())</span>
    <span class="p">});</span>

    <span class="nn">CallbackStatus</span><span class="p">::</span><span class="n">Continue</span>
<span class="p">}</span>
</code></pre>
</div>

<p>I’ve used a <code class="highlighter-rouge">println!</code> here only for the sake of demonstration.
You shouldn’t ever do this in real realtime code.
Print statements are not usually implemented in a realtime safe manner.</p>

<p>This code is to long to past a Rust playground link to, so <a href="/code/sound/arc1.rs">here</a> is the full source.
You can copy/paste the code in to run it.</p>

<p>Here is an example output:</p>
<div class="highlighter-rouge"><pre class="highlight"><code>[realtime] thread started
[ui] thread started
[ui] sending new samples. Second sample: 0
[realtime] received new samples. Second sample: 0
[ui] sending new samples. Second sample: 0.009801715
[realtime] received new samples. Second sample: 0.009801715
[ui] sending new samples. Second sample: 0.01960343
[realtime] received new samples. Second sample: 0.01960343
[ui] sending new samples. Second sample: 0.029405143
[realtime] received new samples. Second sample: 0.029405143
[ui] sending new samples. Second sample: 0.03920686
[realtime] received new samples. Second sample: 0.03920686
[realtime] thread shutting down
[ui] thread shutting down
</code></pre>
</div>

<h1 id="collecting-the-garbage">Collecting the garbage</h1>
<p>The last example seems to be working, but it has one fatal flaw.
Let’s take a look at what the realtime callback does when it receives a new set of samples.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">// ...</span>
<span class="nn">Message</span><span class="p">::</span><span class="nf">NewSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.current_samples</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="p">},</span>
<span class="c">// ...</span>
</code></pre>
</div>

<p>What happens to the old array of samples?
Rust will insert a call to <code class="highlighter-rouge">drop</code> here, because the old value has just gone out of scope.
Something like this (in pseudo-Rust) sort of shows what is going on.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">// ...</span>
<span class="nn">Message</span><span class="p">::</span><span class="nf">NewSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">samples</span><span class="p">);</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">swap</span><span class="p">(</span><span class="k">self</span><span class="py">.current_samples</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
    <span class="k">drop</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">},</span>
<span class="c">// ...</span>
</code></pre>
</div>

<p>When an <code class="highlighter-rouge">Arc</code> gets <code class="highlighter-rouge">drop</code>ped, what happens?
Let’s refer to the docs for <code class="highlighter-rouge">drop</code>.</p>

<blockquote>
  <p>This will decrement the strong reference count. If the strong reference count becomes zero and the only other references are Weak<T> ones, drops the inner value.</T></p>
</blockquote>

<p>We aren’t currently holding on to any other references to this block of memory, so this means that the samples will be deallocated.
This is a problem! We can’t let our realtime callback perform memory allocation.
One (of many) ways to fix this would be to deallocate the list of samples from another thread once no one has a reference to them anymore.
Luckily, an <code class="highlighter-rouge">Arc</code> is reference counted, so we know that we can access this count.
Essentially, we want to create a lightweight garbage collector that will clean up our reference counted, heap allocated samples when we are done with them.
Sneak peak, once the GC is implemented, all we have to change is <code class="highlighter-rouge">UIThread::run</code>, in a very small way:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code>    <span class="c">/// All of the UI thread code</span>
    <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">gc</span> <span class="o">=</span> <span class="nn">GC</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span> <span class="c">// + NEW LINE</span>

        <span class="c">// create 10 "ui events"</span>
        <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="err">..</span><span class="mi">5</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">f32</span> <span class="err">/</span> <span class="mf">10.0</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">samples</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="nf">.compute_samples</span><span class="p">(</span><span class="n">volume</span><span class="p">));</span>
            <span class="n">gc</span><span class="nf">.track</span><span class="p">(</span><span class="n">samples</span><span class="nf">.clone</span><span class="p">());</span> <span class="c">// + NEW LINE</span>

            <span class="c">// send the samples to the other thread</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"[ui] sending new samples. Second sample: {}"</span><span class="p">,</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="k">self</span><span class="py">.outgoing</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Message</span><span class="p">::</span><span class="nf">NewSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c">// tell the other thread to shutdown</span>
        <span class="k">self</span><span class="py">.outgoing</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Message</span><span class="p">::</span><span class="n">Shutdown</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre>
</div>

<p>From the last example, we can roughly define the interface we want our garbage collector to have:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">/// A garbage collector for Arc&lt;T&gt; pointers</span>
<span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">/// Construct a new garbage collector and start the collection thread</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="c">// ...</span>
    <span class="p">}</span>

    <span class="c">/// Instruct the garbage collector to monitor this Arc&lt;T&gt;</span>
    <span class="c">/// When no references remain, the collector will `drop` the value</span>
    <span class="k">fn</span> <span class="nf">track</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre>
</div>

<p>Lets start filling in some of these methods.
First lets think about the <code class="highlighter-rouge">track</code> method.
Let’s just hold onto a vector of all of the pointers we are currently tracking.
This serves two purposes:</p>
<ol>
  <li>Gives us a convinient way to iterate over the data we are tracking.</li>
  <li>Make sure there is always at least 1 reference to the data we are tracking (our own)</li>
</ol>

<p>We care about the second because we never want these <code class="highlighter-rouge">Arc&lt;T&gt;</code>s to be dropped outside of the collector.</p>

<p>Lets go ahead and give this a try:</p>
<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="err">'</span><span class="k">static</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// ...</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">track</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.pool</span><span class="nf">.push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Looks okay to me, now lets think about the logic we will need to implement to do garbage collection.
Since we have a <code class="highlighter-rouge">Vec&lt;Arc&lt;T&gt;&gt;</code>, we will want to iterate over it, removing any elements which meet (or fail) a condition.
We can use <code class="highlighter-rouge">Vec::retain</code> to do this.
Something like the following might work:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="n">pool</span><span class="nf">.retain</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">if</span> <span class="cm">/* has more than one reference */</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">true</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">false</span>
    <span class="p">}</span>
<span class="p">})</span>
</code></pre>
</div>

<p>Looking at the <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code class="highlighter-rouge">Arc</code> docs</a>, there are a few ways we can figure out if the <code class="highlighter-rouge">Arc</code> has only one remaining reference:</p>
<ul>
  <li>Attempt to consume the <code class="highlighter-rouge">Arc</code> with <code class="highlighter-rouge">Arc::try_unwrap</code>, if this fails, we know that it has more than one reference. Unforunately, this method requires moving the <code class="highlighter-rouge">Arc</code> out of the vector, which is not ideal if we want to use <code class="highlighter-rouge">Vec::retain</code>.</li>
  <li><code class="highlighter-rouge">Arc::strong_count</code> - this is currently marked as unstable. Looks like what we might want to use though.</li>
  <li><code class="highlighter-rouge">Arc::get_mut</code> could possibly be used the same way we would use <code class="highlighter-rouge">Arc::try_unwrap</code>, without moving the <code class="highlighter-rouge">Arc</code> containing in the vector unless we want to remove it.</li>
</ul>

<p>We don’t have lots of options, so I’m going to go ahead and use <code class="highlighter-rouge">Arc::strong_count</code>.
This is (for now) the most natural way to solve the problem:</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="n">pool</span><span class="nf">.retain</span><span class="p">(|</span><span class="n">e</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">true</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">false</span>
    <span class="p">}</span>
<span class="p">})</span>
</code></pre>
</div>

<p>Looks okay to me, lets move on to <code class="highlighter-rouge">new</code>.
<code class="highlighter-rouge">new</code> needs to create a new thread which runs the <code class="highlighter-rouge">pool.retain</code> thing we just wrote.
Additionally, if we are going to start a new thread, we will also need to hold on to a handle to join that thread when we shut down.</p>

<div class="language-rust highlighter-rouge"><pre class="highlight"><code><span class="c">/// A garbage collector for Arc&lt;T&gt; pointers</span>
<span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">thread</span><span class="p">:</span> <span class="nn">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="err">'</span><span class="k">static</span><span class="o">&gt;</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pool</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">gc</span> <span class="o">=</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">loop</span> <span class="p">{</span>
                <span class="n">pool</span><span class="nf">.retain</span><span class="p">(|</span><span class="n">e</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">|</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="k">true</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="k">false</span>
                    <span class="p">}</span>
                <span class="p">});</span>

                <span class="k">let</span> <span class="n">sleep</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
                <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">sleep</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">gc_thread</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>

        <span class="n">GC</span> <span class="p">{</span>
            <span class="n">pool</span><span class="p">:</span>   <span class="n">pool</span><span class="p">,</span>
            <span class="n">thread</span><span class="p">:</span> <span class="n">gc_thread</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">track</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.pool</span><span class="nf">.push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>We written a bunch of new code, better make sure it compiles:</p>

<div class="highlighter-rouge"><pre class="highlight"><code>$ rustc test.rs
error[E0277]: the trait bound `T: std::marker::Sync` is not satisfied
  --&gt; test.rs:64:25
   |
64 |         let gc_thread = thread::spawn(gc);
   |                         ^^^^^^^^^^^^^ trait `T: std::marker::Sync` not satisfied
   |
   = help: consider adding a `where T: std::marker::Sync` bound
   = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc&lt;T&gt;`
   = note: required because of the requirements on the impl of `std::marker::Send` for `std::ptr::Unique&lt;std::sync::Arc&lt;T&gt;&gt;`
   = note: required because it appears within the type `alloc::raw_vec::RawVec&lt;std::sync::Arc&lt;T&gt;&gt;`
   = note: required because it appears within the type `std::vec::Vec&lt;std::sync::Arc&lt;T&gt;&gt;`
   = note: required because of the requirements on the impl of `std::marker::Send` for `&amp;mut std::vec::Vec&lt;std::sync::Arc&lt;T&gt;&gt;`
   = note: required because it appears within the type `[closure@test.rs:49:18: 62:10 pool:&amp;mut std::vec::Vec&lt;std::sync::Arc&lt;T&gt;&gt;]`
   = note: required by `std::thread::spawn`

error: aborting due to previous error
</code></pre>
</div>

<p>Oops, this isn’t good.</p>

<p>Let’s try to break this down (emphasis mine):</p>

<!--

## `memcpy` queue
My first solution was the simplest thing I could come up with.
I set up a fixed sized queue between the two threads.
The queue sent complete lists of samples from the UI thread to the realtime thread.
Here's (roughly) how this works:

* The UI thread notices it needs to handle some UI event
* The UI thread recomputes the list of samples and stores them on it's stack
* The UI thread sends the samples to the other thread over the queue (`memcpy` the samples into the queue's buffer)
* Every time the realtime callback is called, it checks the queue for new messages.
* If there are new messages, the samples are `memcpy`ed out of the queue's buffer, into the callback's private buffer (which also lives on the stack).

For a crappy slide show demonstrating this process, [click here](/img/sound/memcpy_queue.pdf).
To get this right, we must be careful with the queue that we use.

First, the queue must not use locks to send messages back and forth.
This we can deal with pretty easily; there are many good lock free queue and ringbuffer implementations.

Second, we must be pretty careful about allocation.
Many queues will create a new "queue node" to hold the data placed on the queue.
When the data is pulled from the queue, the node is deallocated.
We cannot deallocate any queue nodes in the realtime thread.
We also probably shouldn't leak the nodes either, so we need to be careful about allocation of queue nodes.

If we are sure to preallocate everything that the queue will need, and we use a good lock free queue implementation, we get around both of these issues.

Finally, note that it I am totally fine letting the UI thread wait for for space in the queue if the realtime thread is not consuming events fast enough.
I'm assuming that my UI thread is not going to be generating events significantly faster than the realtime thread can consume them.
If it does, there are ways to work around this on the UI thread which I will not get into now (maybe in a future post).

It looks like we can probably pull this off.
`memcpy` is pretty fast, so we can probably afford to do a large `memcpy` in the realtime thread every once and a while, but it's not a very good idea to do something slow at effectively random times in the realtime thread.
It also just feels wrong to make so many copies.
I'm sure we can do better.

## Pointer queue
All problems in computer science can be solved by adding a layer of indirection (or so they say).
Let's try to get rid of all of these copies with pointers!
We will heap allocate some samples samples on the UI thread, populate them, then pass a pointer to those samples to the realtime thread.
Again, we need to use a carefully constructed, bounded, lock-free queue.

When there is a message available for the realtime thread, all it has to do is swap its `current` pointer with the new pointer that came over the queue.

But wait!
What will we do with the previous list of samples?
We can't free this memory in the realtime thread, and we definitely don't want to leak it, so we need to send it to some other thread to be freed (or reused).
Let's just send the memory back to the UI thread, then let the UI thread deal with it (perhaps it can even reuse the memory).

This seems plausible, but there are some complications we must work around:
1. We cannot use an unbounded queue to send samples from the realtime thread to the UI thread.
    * As far as I know, there are no unbounded queues which do not perform allocation when sending messages.
2. We cannot use a blocking, bounded queue to send the memory back to the UI thread.

TODO this might actually be doable

To understand the first of these, consider this scenario.
If the queue is full, we will have to wait until there is room on the queue to push the new pointers.
Remember that the UI thread is not running in realtime.
It might not have been run by the scheduler recently, so it may not have had a chance to drain the queue the next time the realtime thread

* We cannot cache the pointers in the realtime thread when the queue is full
    * The cache of pointers would need to be unbounded (the required size is non-deterministic).
        * In order to create an unbounded list of something, we need to allocate.

### Double buffering
If we get rid of the queue and replace it with two pointers, we swap between the two states with some atomic operations.
[JackAtomicState.h](https://github.com/jackaudio/jack2/blob/364159f8212393442670b9c3b68b75aa39d98975/common/JackAtomicState.h) is an example of such a thing.
Unfortunately, we must keep in mind that the UI thread is not realtime.
If we want to avoid leaks, we must make sure that we never overwrite something before it is freed.

I'm sure there are some ways to work around all the double buffering/pointer queue issues, but frankly, I don't want to, my gut and a few hours of thought have declared any solutions I've come up with too complicated for comfort.

# A "Garbage Collector"
At this point, I considered shipping reference counted objects around to manage these issues (and use the reference count to figure out when to free them).
I wasn't totally confident that this was a good idea, until I watched the [cppcon video](https://www.youtube.com/watch?v=boPEO2auJj4), in which the speaker builds a simple "garbage collector" for `std::shared_ptr` and says "yes this is a good idea."

Here begins the discussion about how I've done the same thing in rust.

TODO touchy bit about page faults

# rust stuff


<figure class="highlight"><pre><code class="language-rust" data-lang="rust"><span class="err">#</span><span class="o">!</span><span class="p">[</span><span class="nf">feature</span><span class="p">(</span><span class="n">arc_counts</span><span class="p">)]</span>

<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nn">mpsc</span><span class="p">::</span><span class="n">SyncSender</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="n">mpsc</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::{</span><span class="nb">Arc</span><span class="p">,</span> <span class="n">Mutex</span><span class="p">};</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>
<span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">time</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">TrustMe</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">data</span><span class="p">:</span> <span class="n">T</span>
<span class="p">}</span>

<span class="c">//unsafe impl&lt;T&gt; Sync for TrustMe&lt;T&gt; {}</span>
<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">TrustMe</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>

<span class="c">/// Doesn't do anything with the pointer until it has no references other than itself</span>
<span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="err">'</span><span class="k">static</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TrustMe</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">thread</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">notify</span><span class="p">:</span> <span class="n">SyncSender</span><span class="o">&lt;</span><span class="nb">bool</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="err">'</span><span class="k">static</span><span class="o">&gt;</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pool</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()));</span>

        <span class="k">let</span> <span class="p">(</span><span class="n">rx</span><span class="p">,</span> <span class="n">tx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nf">sync_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

        <span class="k">let</span> <span class="n">tpool</span> <span class="o">=</span> <span class="n">pool</span><span class="nf">.clone</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">gc</span> <span class="o">=</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">loop</span> <span class="p">{</span>
                <span class="k">match</span> <span class="n">tx</span><span class="nf">.try_recv</span><span class="p">()</span> <span class="p">{</span>
                    <span class="nf">Ok</span><span class="p">(</span><span class="n">_</span><span class="p">)</span>  <span class="k">=&gt;</span> <span class="k">break</span><span class="p">,</span>
                    <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">()</span>
                <span class="p">};</span>

                <span class="k">let</span> <span class="k">mut</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">tpool</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                <span class="n">pool</span><span class="nf">.retain</span><span class="p">(|</span><span class="n">e</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrustMe</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">|</span> <span class="p">{</span>
                    <span class="k">if</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="py">.data</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                        <span class="k">return</span> <span class="k">true</span>
                    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                        <span class="nd">println!</span><span class="p">(</span><span class="s">"doing a drop"</span><span class="p">);</span>
                        <span class="k">return</span> <span class="k">false</span>
                    <span class="p">}</span>
                <span class="p">});</span>

                <span class="k">let</span> <span class="n">ten_millis</span> <span class="o">=</span> <span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
                <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">ten_millis</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="k">let</span> <span class="n">gc_thread</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>

        <span class="n">GC</span> <span class="p">{</span>
            <span class="n">pool</span><span class="p">:</span> <span class="n">pool</span><span class="p">,</span>
            <span class="n">thread</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">gc_thread</span><span class="p">),</span>
            <span class="n">notify</span><span class="p">:</span> <span class="n">rx</span><span class="p">,</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">track</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">p</span> <span class="o">=</span> <span class="k">self</span><span class="py">.pool</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="k">let</span> <span class="n">trust</span> <span class="o">=</span> <span class="n">TrustMe</span> <span class="p">{</span> <span class="n">data</span><span class="p">:</span> <span class="n">t</span> <span class="p">};</span>
        <span class="n">p</span><span class="nf">.push</span><span class="p">(</span><span class="n">trust</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="err">'</span><span class="k">static</span><span class="o">&gt;</span> <span class="n">Drop</span> <span class="k">for</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="k">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"collector going down!"</span><span class="p">);</span>
        <span class="k">self</span><span class="py">.notify</span><span class="nf">.send</span><span class="p">(</span><span class="k">true</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>

        <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="k">self</span><span class="py">.thread</span><span class="nf">.take</span><span class="p">();</span>
        <span class="k">match</span> <span class="n">t</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">t</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
            <span class="nb">None</span>    <span class="k">=&gt;</span> <span class="p">()</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">struct</span> <span class="n">LoudDrop</span> <span class="p">{</span> <span class="p">}</span>
<span class="k">impl</span> <span class="n">LoudDrop</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span> <span class="n">LoudDrop</span> <span class="p">{}</span> <span class="p">}</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">Drop</span> <span class="k">for</span> <span class="n">LoudDrop</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="k">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"being dropped"</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">mem</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">LoudDrop</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>
    <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">collector</span> <span class="o">=</span> <span class="nn">GC</span><span class="p">::</span><span class="o">&lt;</span><span class="n">LoudDrop</span><span class="o">&gt;</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
        <span class="n">collector</span><span class="nf">.track</span><span class="p">(</span><span class="n">mem</span><span class="nf">.clone</span><span class="p">());</span>

        <span class="p">{</span>
            <span class="k">let</span> <span class="n">mem</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">LoudDrop</span><span class="p">::</span><span class="nf">new</span><span class="p">());</span>
            <span class="n">collector</span><span class="nf">.track</span><span class="p">(</span><span class="n">mem</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="k">let</span> <span class="n">ten_millis</span> <span class="o">=</span> <span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
            <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">ten_millis</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">let</span> <span class="n">ten_millis</span> <span class="o">=</span> <span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
        <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">ten_millis</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>


-->

</article>







      </div>
    </div>
  </div>

  <footer class="footer">
  <div class="p2 wrap">
    <div class="measure mt1 center">
      <small>
        Theme crafted with &lt;3 by <a href="http://johnotander.com">John Otander</a> (<a href="https://twitter.com/4lpine">@4lpine</a>).<br>
      </small>
    </div>
  </div>
</footer>



<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</body>
</html>
