<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>"Garbage collection" for Rust Arc Pointers &#8211; dpzmick.com</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Cleaning up after yourself in realtime">
    <meta name="author" content="David Zmick">
    <meta name="keywords" content="">
    <link rel="canonical" href="http://0.0.0.0:4000/2017/01/23/rust-arc-gc-realtime/">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css" type="text/css">

    <!-- MathJax config -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax:        ["input/TeX", "output/HTML-CSS"],
        tex2jax:    {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
        },
        "HTML-CSS": {
             availableFonts:
             ["TeX"]
        }
    });
    </script>

    <!-- Fonts -->
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
      <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content=""Garbage collection" for Rust Arc Pointers">
    <meta property="og:description" content="Just some dude's blog">
    <meta property="og:url" content="http://0.0.0.0:4000/2017/01/23/rust-arc-gc-realtime/">
    <meta property="og:site_name" content="dpzmick.com">

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
</head>

<body class="">
  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://0.0.0.0:4000" class="site-title">dpzmick.com</a>
      <nav class="site-nav right">
        <a href="/about/">About</a>
<a href="/series/">Blog Series</a>
<a href="http://dpzmick.com/resume/resume.pdf">Resume</a>

      </nav>
      <div class="clearfix"></div>
      
        <div class="social-icons">
  <div class="left">
    
      <a class="fa fa-github" href="https://github.com/dpzmick"></a>
    
    
    <a class="fa fa-rss" href="/feed.xml"></a>
    
    

    
      <a class="fa fa-linkedin" href="https://www.linkedin.com/in/dpzmick"></a>
    
  </div>
  <div class="right">
    
    
    
  </div>
</div>
<div class="clearfix"></div>

      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        <div class="post-header mb2">
  <h1>"Garbage collection" for Rust Arc Pointers</h1>
  <span class="post-meta">Jan 23, 2017</span><br>
  
</div>

<article class="post-content">
  <p>Recently, I’ve been working on a synthesizer (the kind that makes sounds) in Rust.
This post is the second post in a series of posts about this project.
See my <a href="/series/">blog series</a> page for links to other posts.</p>

<p>If you don’t know anything at all about realtime audio programming, you might want to read the first post in this series, <a href="/2016/12/17/audio-basics/">Audio Programming 101</a>, or watch <a href="https://www.youtube.com/watch?v=SJXGSJ6Zoro">this talk</a> from the Audio Developers Conference, to get a little bit of background.</p>

<p>In short, there’s a realtime thread that can never be blocked in any way.
The realtime thread is responsible for sending all of the audio which an application will produce to an audio system, at exactly the right moments.
If the realtime thread ever fails to generate the audio it needs to generate, bad things happen.
That means locks, I/O, allocation are all off limits in the realtime thread.</p>

<p>Sending messages from non-realtime threads to the realtime thread is trickier than it might be in a “normal” application because we can’t do these things.
There are many, many techniques which can be used to work around this trickiness.
This post is a discussion of one such method (presented in <a href="https://www.youtube.com/watch?v=boPEO2auJj4">this cppcon talk</a>) implemented in <a href="https://www.rust-lang.org/en-US/">Rust</a>.</p>

<h1 id="messaging-between-threads">Messaging between threads</h1>
<p>Suppose we are developing a synthesizer which produces sounds when keys are pressed on a <a href="https://en.wikipedia.org/wiki/MIDI_controller#Keyboards">MIDI keyboard</a>.
The audio library calls a function we provide once ever 6 or so milliseconds to request a list of samples from us.
The library calls our function with 2 arguments: 1) How many samples it wants 2) what key presses we need to handle.
The callback function uses a precomputed list of samples to generate sounds every time it is called.
To modify the properties of the sounds that are produced, the user edits settings with a user interface.</p>

<p>It would be painful (and incorrect) to attempt to handle UI events in the realtime thread, so we will run a UI thread to handle the UI events.
Whenever the UI thread gets an event to handle, it needs to compute a new sample list, then send the list to the realtime thread.</p>

<p>Since we can’t lock, let’s use a queue to send some sort of message between threads.
The queue that we choose needs to have a few properties:</p>

<ul>
  <li>Must be a <a href="https://pdfs.semanticscholar.org/a909/1ef790788c5d252cad94dd6862adf457e073.pdf">lock free queue</a></li>
  <li>Must be able to preallocate all of its nodes (cant’t allocate or free memory for a node on a push or pull)</li>
</ul>

<p>I want to place messages on the heap so that they do not need to be copied as we move them around.
If messages lives on the heap, we must ensure they are allocated and freed outside of the realtime thread (we can’t call allocation functions on the realtime thread).</p>

<h2 id="reference-counted-garbage-collection">Reference counted garbage collection</h2>
<p>It is totally fine to allocate on the UI thread, so when the UI thread handles an event it will compute a new list of samples and stick them into a freshly allocated block of memory.
Then we will ship this message over to the realtime thread.</p>

<p>When the realtime thread takes ownership of the message, it will need to hold onto the data for some undefined period of time.
But, when the realtime thread is done with the message, it cannot free it (because we can’t allocate or deallocatein the realtime thread).</p>

<p>To solve this, let’s run one more thread to clean up messages which are no longer being used by the realtime thread.</p>

<p>Whenever the UI thread allocates space for a message using standard allocators, it will wrap the message in a <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html">reference-counted pointer</a>.
It then will let the collector thread know it should start keeping an eye on the reference-counted pointer.
The collector will store the pointer in a list.
When the reference count falls to 1, the collector is the only thread with a reference, and it can safely free the memory.
The pointer is sent to the realtime thread, then, when the realtime thread drops the message, the reference count will drop.
Sometime later, the collector thread will observe the decreased reference count and free the message.</p>

<p><a href="/img/sound/gc_queue.pdf">Here</a> is a slideshow/animation demonstrating this process.</p>

<h2 id="tradeoffs">Tradeoffs</h2>
<p>Let’s consider the theoretical behavior of this approach.
Note that anything I have to say should be taken with grain of salt; I haven’t benchmarked anything, so I really have no evidence to support anything I’m claiming.</p>

<p>First, let’s talk about when we would not want to use this approach.</p>

<p>If the realtime thread always consumes new messages in a predictable amount of time, we can preallocate a certain number of messages and just keep reusing the same blocks of memory.
When the UI needs to send a message it can grab one of the preallocated messages and use it.
Some predictable amount of time later, when the realtime thread is done with it, the message can be returned to the pool (by the realtime thread).</p>

<p>This is also a bad idea if the UI thread generates messages significantly faster than the realtime thread consumes them.
It might be fine for the realtime thread to lag behind the UI thread (if it eventually catches up), but the GC pointer list is going to get quite large.
If we do our GC scan frequently, we will be using a lot of cpu time scanning this list.
If we slow the collector down, the list is going to keep growing, and so will our memory usage.
In other words, it’s a sticky situation.
A modern computer can probably handle this load, but we should avoid generating more load than necessary so that other audio applications running at the same time can use as much time as they need.</p>

<p>Finally, if the realtime thread needs to send a message to the UI thread, it can’t just allocate memory and toss it at the GC thread for cleanup later.
We could still use the GC+queue method discussed here to send messages to the realtime thread, but we probably only have time to build one good messaging system (we want to make audio, not send messages back and forth!)</p>

<p>If none of the above are true, a simple GC thread with some reference counted pointers might be a nice way to avoid adding lots of complexity to a small system.
It also saves us from the need for a custom allocation mechanism, lets us send messages of various and dynamic sizes, and frees us from the burden of strict capacity constraints.
So, if we don’t need something more clever, maybe this is a good thing to try out.</p>

<p>Finally, since we are using reference counting to manage memory, there will be some runtime cost to increment and decrement the reference counts.
This isn’t a big deal for us, in this case, because the performance is predictable (we won’t be suddenly surprised by the non-deterministic reference count incrementing).</p>

<p>There are many other variations of this technique (some which involve extra threads, some which don’t, some which reuse freed memory, etc).
Regardless of the actual efficacy of this approach, it will be interesting to try to build one in Rust, so let’s get started.</p>

<h1 id="lets-make-one">Let’s make one</h1>
<p>For the sake of these examples, let’s assume that the built-in Rust <a href="https://doc.rust-lang.org/std/sync/mpsc/index.html">mpsc channel</a> is an appropriate lock free queue.
It will be pretty easy to swap this with something different later, and, if we use the standard library, all of the examples will easily run in the Rust playground.
We are also going to fake a bunch of the details of the audio library.</p>

<h2 id="fake-audio-library">Fake audio library</h2>
<p><a href="https://play.rust-lang.org/?gist=27d1b7a693ffe01ac899b991317b170f&amp;version=stable&amp;backtrace=0">Rust Playground Link</a>.</p>

<p>We don’t need to walk through this code, it just makes some threads and calls some empty functions.
The important bits are the <code class="highlighter-rouge">RealtimeThread::realtime_callback</code> function and the <code class="highlighter-rouge">UIThread::run</code> functions.
In this example, the realtime callback function says “I’m done!” to let the realtime thread shutdown, and the UI thread does nothing at all.</p>

<p>Here’s the code:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">use</span> <span class="nn">std</span><span class="p">::</span><span class="n">thread</span><span class="p">;</span>

<span class="nd">#[derive(PartialEq)]</span>
<span class="k">enum</span> <span class="n">CallbackStatus</span> <span class="p">{</span>
    <span class="n">Continue</span><span class="p">,</span>
    <span class="n">Shutdown</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// "library" code starts here</span>
<span class="k">type</span> <span class="n">Samples</span> <span class="o">=</span> <span class="p">[</span><span class="nb">f32</span><span class="p">;</span> <span class="mi">64</span><span class="p">];</span>

<span class="k">fn</span> <span class="nf">run_threads</span><span class="p">(</span><span class="k">mut</span> <span class="n">rt</span><span class="p">:</span> <span class="n">RealtimeThread</span><span class="p">,</span> <span class="k">mut</span> <span class="n">ui</span><span class="p">:</span> <span class="n">UIThread</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">join_handle</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"[ui] thread started"</span><span class="p">);</span>
        <span class="n">ui</span><span class="nf">.run</span><span class="p">();</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"[ui] thread shutting down"</span><span class="p">);</span>
    <span class="p">});</span>

    <span class="nd">println!</span><span class="p">(</span><span class="s">"[realtime] thread started"</span><span class="p">);</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">output</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">;</span> <span class="mi">64</span><span class="p">];</span>
    <span class="k">while</span> <span class="n">rt</span><span class="nf">.realtime_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">output</span><span class="p">)</span> <span class="o">!=</span> <span class="nn">CallbackStatus</span><span class="p">::</span><span class="n">Shutdown</span> <span class="p">{</span> <span class="p">}</span>
    <span class="nd">println!</span><span class="p">(</span><span class="s">"[realtime] thread shutting down"</span><span class="p">);</span>

    <span class="n">join_handle</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
<span class="c">// end of "library" code</span>

<span class="c">/// A struct containing the realtime callback and all data owned by the realtime thread</span>
<span class="k">struct</span> <span class="n">RealtimeThread</span> <span class="p">{</span>
    <span class="c">// some members here eventually</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">RealtimeThread</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span> <span class="n">RealtimeThread</span><span class="p">{}</span> <span class="p">}</span>

    <span class="c">/// realtime callback, called to get the list of samples</span>
    <span class="k">fn</span> <span class="nf">realtime_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">output_samples</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Samples</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CallbackStatus</span> <span class="p">{</span>
        <span class="nn">CallbackStatus</span><span class="p">::</span><span class="n">Shutdown</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">/// A struct which runs the UI thread and contains all of the data owned by the UI thread</span>
<span class="k">struct</span> <span class="n">UIThread</span> <span class="p">{</span>
    <span class="c">// some members here eventually</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">UIThread</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span> <span class="n">UIThread</span><span class="p">{}</span> <span class="p">}</span>

    <span class="c">/// All of the UI thread code</span>
    <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// do nothing!</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">rt</span> <span class="o">=</span> <span class="nn">RealtimeThread</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="k">let</span> <span class="n">ui</span> <span class="o">=</span> <span class="nn">UIThread</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>
    <span class="nf">run_threads</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Output (one of many possible):</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[realtime] thread started
[realtime] thread shutting down
[ui] thread started
[ui] thread shutting down
</code></pre></div></div>

<h2 id="sending-arcs-between-threads">Sending Arcs between threads</h2>
<p>Now that we have an “audio library,” let’s try to make some messages and pass them between threads.</p>

<p>The <code class="highlighter-rouge">RealtimeThread</code> struct will need to hold on to a list of samples which it will use to populate the <code class="highlighter-rouge">output</code> samples every time the callback is called.
We want these samples to be heap allocated and reference counted, so we wrap them in an <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code class="highlighter-rouge">Arc</code></a>.
Finally, we want to leave the samples uninitialized until the UI thread sends us some, so we wrap the <code class="highlighter-rouge">Arc&lt;Samples&gt;</code> in an <a href="https://doc.rust-lang.org/std/option/enum.Option.html"><code class="highlighter-rouge">Option</code></a>.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">RealtimeThread</span> <span class="p">{</span>
  <span class="n">current_samples</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Samples</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now that the realtime thread has a list of samples, we can fill in a bit of the body of the realtime callback function:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">realtime_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">output_samples</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Samples</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CallbackStatus</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.current_samples</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">samples</span><span class="p">|</span> <span class="p">{</span>
        <span class="c">// samples: &amp;Arc&lt;[f32; 64]&gt;</span>
        <span class="n">output_samples</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">samples</span><span class="nf">.as_ref</span><span class="p">())</span>
    <span class="p">});</span>

    <span class="nn">CallbackStatus</span><span class="p">::</span><span class="n">Continue</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The function <a href="https://doc.rust-lang.org/std/primitive.slice.html#method.copy_from_slice"><code class="highlighter-rouge">copy_from_slice</code></a> will <code class="highlighter-rouge">memcpy</code> the samples we are holding onto into the buffer provided by the audio library.</p>

<p>Moving over to the UI thread, first, we need to be able to compute a list of samples to compute.
Here is a function that computes 64 samples along a sine wave with a given peak amplitude:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// computes the samples needed for on cycle of a sine wave</span>
<span class="c">/// the volume parameter sets the audible volume of sound produced</span>
<span class="k">fn</span> <span class="nf">compute_samples</span><span class="p">(</span><span class="o">&amp;</span><span class="k">self</span><span class="p">,</span> <span class="n">volume</span><span class="p">:</span> <span class="nb">f32</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Samples</span> <span class="p">{</span>
    <span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="n">volume</span> <span class="o">&gt;=</span> <span class="mf">0.0</span><span class="p">);</span>
    <span class="k">assert</span><span class="o">!</span><span class="p">(</span><span class="n">volume</span> <span class="o">&lt;=</span> <span class="mf">1.0</span><span class="p">);</span>

    <span class="c">// we need to populate 64 samples with 1 cycle of a sine wave (arbitrary choice)</span>
    <span class="k">let</span> <span class="n">constant_factor</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1.0</span><span class="err">/</span><span class="mf">64.0</span><span class="p">)</span> <span class="o">*</span> <span class="mf">2.0</span> <span class="o">*</span> <span class="nn">f32</span><span class="p">::</span><span class="nn">consts</span><span class="p">::</span><span class="n">PI</span><span class="p">;</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">samples</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.0</span><span class="p">;</span> <span class="mi">64</span><span class="p">];</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">64</span> <span class="p">{</span>
        <span class="n">samples</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">constant_factor</span> <span class="o">*</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">f32</span><span class="p">)</span><span class="nf">.sin</span><span class="p">()</span> <span class="o">*</span> <span class="n">volume</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">samples</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The UI thread will generate some fake events, and compute samples for these events:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// All of the UI thread code</span>
<span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// create 5 "ui events"</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">f32</span> <span class="err">/</span> <span class="mf">10.0</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">samples</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="nf">.compute_samples</span><span class="p">(</span><span class="n">volume</span><span class="p">));</span>

        <span class="c">// send the samples to the other thread</span>
    <span class="p">}</span>

    <span class="c">// tell the other thread to shutdown</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now that we’ve done all of that, we need to send the samples between threads.</p>

<h2 id="message-type">Message type</h2>

<p>As discussed previously, we will create the <code class="highlighter-rouge">Arc</code> on the UI thread, then send it to the realtime thread.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">enum</span> <span class="n">Message</span> <span class="p">{</span>
    <span class="nf">NewSamples</span><span class="p">(</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Samples</span><span class="o">&gt;</span><span class="p">),</span>
    <span class="n">Shutdown</span><span class="p">,</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Remember when I said that we would make a bunch of assumptions about the <code class="highlighter-rouge">mpsc</code> queues?
Here’s where I’m going to do that.
We are going to assume that this queue follows all the properties we need a realtime queue to follow.
For a quick reminder, those are:</p>
<ul>
  <li>No locks</li>
  <li>No allocation (or deallocation) in the realtime thread.</li>
</ul>

<p>To send messages between the threads, we will use <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.sync_channel.html"><code class="highlighter-rouge">mpcs::sync_channel</code></a> to create a synchronous channel (queue).
This channel is bounded, so a sender cannot add a new message to the queue unless there is currently space available.
We are going to set the buffer size to zero.
From <a href="https://doc.rust-lang.org/std/sync/mpsc/fn.sync_channel.html">the docs</a>:</p>

<blockquote>
  <p>Note that a buffer size of 0 is valid, in which case this [channel] becomes “rendezvous channel” where each send will not return until a recv is paired with it.</p>
</blockquote>

<p>This “channel” will have two ends; one which can send messages and one which can receive messages.
Lets create both of them in the <code class="highlighter-rouge">main</code> method.
The send side will be called <code class="highlighter-rouge">tx</code> (for transmit) and the receive side is called <code class="highlighter-rouge">rx</code>.
Whenever a message is placed on <code class="highlighter-rouge">tx</code> it will become available on <code class="highlighter-rouge">rx</code>.</p>

<p>Then, we let each of our threads take ownership of the appropriate channel.
We give <code class="highlighter-rouge">rx</code> to the <code class="highlighter-rouge">RealtimeThread</code>, because it will receive messages, and <code class="highlighter-rouge">tx</code> to the <code class="highlighter-rouge">UIThread</code>, because it will be sending them.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nf">sync_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">rt</span> <span class="o">=</span> <span class="nn">RealtimeThread</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">ui</span> <span class="o">=</span> <span class="nn">UIThread</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">tx</span><span class="p">);</span>
    <span class="nf">run_threads</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, modify both thread structs and both <code class="highlighter-rouge">new</code> functions.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">RealtimeThread</span> <span class="p">{</span>
    <span class="n">current_samples</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Samples</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">incoming</span><span class="p">:</span>        <span class="nn">mpsc</span><span class="p">::</span><span class="n">Receiver</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// ...</span>

<span class="k">struct</span> <span class="n">UIThread</span> <span class="p">{</span>
    <span class="n">outgoing</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">SyncSender</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// changes to new omitted</span>
</code></pre></div></div>

<p>Now, let’s get our threads sending messages, starting with the UI thread.
If any sends fails, something has gone horribly wrong, so its fine to <code class="highlighter-rouge">unwrap</code> the result of these sends.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// All of the UI thread code</span>
<span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">// create 10 "ui events"</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">10</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">f32</span> <span class="err">/</span> <span class="mf">10.0</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">samples</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="nf">.compute_samples</span><span class="p">(</span><span class="n">volume</span><span class="p">));</span>

        <span class="c">// send the samples to the other thread</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"[ui] sending new samples. Second sample: {}"</span><span class="p">,</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">self</span><span class="py">.outgoing</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Message</span><span class="p">::</span><span class="nf">NewSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c">// tell the other thread to shutdown</span>
    <span class="k">self</span><span class="py">.outgoing</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Message</span><span class="p">::</span><span class="n">Shutdown</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the realtime thread, we check if there is a new message on the queue.
If there is, handle it.
If not, just keep doing what we were doing.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// realtime callback, called to get the list of samples</span>
<span class="k">fn</span> <span class="nf">realtime_callback</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">output_samples</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="n">Samples</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">CallbackStatus</span> <span class="p">{</span>
    <span class="k">match</span> <span class="k">self</span><span class="py">.incoming</span><span class="nf">.try_recv</span><span class="p">()</span> <span class="p">{</span>
        <span class="c">// we've received a messaged</span>
        <span class="nf">Ok</span><span class="p">(</span><span class="n">message</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="k">match</span> <span class="n">message</span> <span class="p">{</span>
            <span class="nn">Message</span><span class="p">::</span><span class="nf">NewSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
                <span class="nd">println!</span><span class="p">(</span><span class="s">"[realtime] received new samples. Second sample: {}"</span><span class="p">,</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
                <span class="k">self</span><span class="py">.current_samples</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
            <span class="p">},</span>

            <span class="c">// If we got a shutdown message, shutdown the realtime thread</span>
            <span class="nn">Message</span><span class="p">::</span><span class="n">Shutdown</span> <span class="k">=&gt;</span> <span class="k">return</span> <span class="nn">CallbackStatus</span><span class="p">::</span><span class="n">Shutdown</span>
        <span class="p">},</span>

        <span class="c">// if we didn't receive anything, just keep sending samples</span>
        <span class="nf">Err</span><span class="p">(</span><span class="n">_</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">()</span>
    <span class="p">}</span>

    <span class="c">// copy our current samples into the output buffer</span>
    <span class="k">self</span><span class="py">.current_samples</span><span class="nf">.as_ref</span><span class="p">()</span><span class="nf">.map</span><span class="p">(|</span><span class="n">samples</span><span class="p">|</span> <span class="p">{</span>
        <span class="c">// samples: &amp;Arc&lt;[f32; 64&gt;</span>
        <span class="n">output_samples</span><span class="nf">.copy_from_slice</span><span class="p">(</span><span class="n">samples</span><span class="nf">.as_ref</span><span class="p">())</span>
    <span class="p">});</span>

    <span class="nn">CallbackStatus</span><span class="p">::</span><span class="n">Continue</span>
<span class="p">}</span>
</code></pre></div></div>

<p>I’ve used a <code class="highlighter-rouge">println!</code> here only for the sake of demonstration.
You shouldn’t ever do this in real realtime code (because print statements usually allocate!)</p>

<p><a href="https://play.rust-lang.org/?gist=6e37aa0a7f8d06f8b31b9822c8bbb79c&amp;version=stable&amp;backtrace=0">Here is a link</a> to this code in the Rust playground.
It might timeout if you try running it. If you see any messages about timeout, don’t worry, just try running the code again.</p>

<p>Here is an example output:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[realtime] thread started
[ui] thread started
[ui] sending new samples. Second sample: 0
[realtime] received new samples. Second sample: 0
[ui] sending new samples. Second sample: 0.009801715
[realtime] received new samples. Second sample: 0.009801715
[ui] sending new samples. Second sample: 0.01960343
[realtime] received new samples. Second sample: 0.01960343
[ui] sending new samples. Second sample: 0.029405143
[realtime] received new samples. Second sample: 0.029405143
[ui] sending new samples. Second sample: 0.03920686
[realtime] received new samples. Second sample: 0.03920686
[realtime] thread shutting down
[ui] thread shutting down
</code></pre></div></div>

<h2 id="problems">Problems?</h2>
<p>The last example <em>seems</em> to do the right thing, let’s take a look at what the realtime callback does when it receives a new set of samples.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// ...</span>
<span class="nn">Message</span><span class="p">::</span><span class="nf">NewSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="k">self</span><span class="py">.current_samples</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span>
<span class="p">},</span>
<span class="c">// ...</span>
</code></pre></div></div>

<p>What happens to the old array of samples?
Rust will insert a call to <code class="highlighter-rouge">drop</code> here, because the old value has just gone out of scope.
Something like this (in pseudo-Rust) sort of shows what is going on.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// ...</span>
<span class="nn">Message</span><span class="p">::</span><span class="nf">NewSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="p">{</span>
    <span class="k">let</span> <span class="n">tmp</span> <span class="o">=</span> <span class="nf">Some</span><span class="p">(</span><span class="n">samples</span><span class="p">);</span>
    <span class="nn">mem</span><span class="p">::</span><span class="nf">swap</span><span class="p">(</span><span class="k">self</span><span class="py">.current_samples</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
    <span class="k">drop</span><span class="p">(</span><span class="n">tmp</span><span class="p">);</span>
<span class="p">},</span>
<span class="c">// ...</span>
</code></pre></div></div>

<p>When an <code class="highlighter-rouge">Arc</code> gets <code class="highlighter-rouge">drop</code>ped, what happens?
Let’s refer to the docs for <code class="highlighter-rouge">drop</code>.</p>

<blockquote>
  <p>This will decrement the strong reference count. If the strong reference count becomes zero and the only other references are Weak<T> ones, drops the inner value.</T></p>
</blockquote>

<p>In this case, the inner value is some heap allocated memory, so calling drop will deallocate that memory (since no one else is holding any references).
This is a problem!
We can’t let our realtime callback perform memory allocation.</p>

<h1 id="build-the-gc">Build the GC</h1>

<p>We now need to build the GC that I promised we would build, to clean up after us, outside of the realtime thread.
Sneak peak, once the GC is implemented, all we have to change is <code class="highlighter-rouge">UIThread::run</code>, in a very small way:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// All of the UI thread code</span>
<span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">let</span> <span class="k">mut</span> <span class="n">gc</span> <span class="o">=</span> <span class="nn">GC</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span> <span class="c">// + NEW LINE</span>

    <span class="c">// create 5 "ui events"</span>
    <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">f32</span> <span class="err">/</span> <span class="mf">5.0</span><span class="p">;</span>
        <span class="k">let</span> <span class="n">samples</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="nf">.compute_samples</span><span class="p">(</span><span class="n">volume</span><span class="p">));</span>
        <span class="k">self</span><span class="py">.collector</span><span class="nf">.track</span><span class="p">(</span><span class="n">samples</span><span class="nf">.clone</span><span class="p">());</span> <span class="c">// + NEW LINE</span>

        <span class="c">// send the samples to the other thread</span>
        <span class="nd">println!</span><span class="p">(</span><span class="s">"[ui] sending new samples. Second sample: {}"</span><span class="p">,</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
        <span class="k">self</span><span class="py">.outgoing</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Message</span><span class="p">::</span><span class="nf">NewSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c">// tell the other thread to shutdown</span>
    <span class="k">self</span><span class="py">.outgoing</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Message</span><span class="p">::</span><span class="n">Shutdown</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
<span class="p">}</span>
</code></pre></div></div>

<p>With that in mind, lets sketch out the interface for the Garbage Collector.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// A garbage collector for Arc&lt;T&gt; pointers</span>
<span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// ...</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">/// Construct a new garbage collector and start the collection thread</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="c">// ...</span>
    <span class="p">}</span>

    <span class="c">/// Instruct the garbage collector to monitor this Arc&lt;T&gt;</span>
    <span class="c">/// When no references remain, the collector will `drop` the value</span>
    <span class="k">fn</span> <span class="nf">track</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// ...</span>
    <span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>First think about the <code class="highlighter-rouge">track</code> method.
All this method needs to do is move it’s argument into some list (vector) of pointers.
We will keep this vector in the GC thread struct so that each of the references will live until the GC thread is shut down or until the GC drops them.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// ...</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">track</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.pool</span><span class="nf">.push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now lets think about the garbage collection logic.
Since we have a <code class="highlighter-rouge">Vec&lt;Arc&lt;T&gt;&gt;</code>, we will want to iterate over it, removing any elements which meet (or fail) a condition.
We can use <code class="highlighter-rouge">Vec::retain</code> to do this.
Something like the following might work:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pool</span><span class="nf">.retain</span><span class="p">(|</span><span class="n">e</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">if</span> <span class="cm">/* has more than one reference */</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">true</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">false</span>
    <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Looking at the <a href="https://doc.rust-lang.org/std/sync/struct.Arc.html"><code class="highlighter-rouge">Arc</code> docs</a>, there are a few ways we can figure out if the <code class="highlighter-rouge">Arc</code> has only one remaining reference:</p>
<ul>
  <li>Attempt to consume the <code class="highlighter-rouge">Arc</code> with <code class="highlighter-rouge">Arc::try_unwrap</code>, if this fails, we know that it has more than one reference. Unforunately, this method requires moving the <code class="highlighter-rouge">Arc</code> out of the vector, which is not ideal if we want to use <code class="highlighter-rouge">Vec::retain</code>.</li>
  <li><code class="highlighter-rouge">Arc::strong_count</code> - this is currently marked as unstable. Looks like what we might want to use though.</li>
  <li><code class="highlighter-rouge">Arc::get_mut</code> could possibly be used the same way we would use <code class="highlighter-rouge">Arc::try_unwrap</code>, without moving the <code class="highlighter-rouge">Arc</code> containing in the vector unless we want to remove it.</li>
</ul>

<p>We don’t have lots of options, so I’m going to go ahead and use <code class="highlighter-rouge">Arc::strong_count</code>.
This is (for now) the most natural way to solve the problem:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">pool</span><span class="nf">.retain</span><span class="p">(|</span><span class="n">e</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">|</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">true</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="k">return</span> <span class="k">false</span>
    <span class="p">}</span>
<span class="p">})</span>
</code></pre></div></div>

<p>Let’s move on to <code class="highlighter-rouge">new</code>.
The <code class="highlighter-rouge">new</code> method needs to start new thread which will run the <code class="highlighter-rouge">pool.retain</code> thing every once and a while.
We also need to hold on to a thread handle so that we can eventually join the thread.
The join handle is wrapped in an <code class="highlighter-rouge">Option</code>, we will see why quite a bit later.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// A garbage collector for Arc&lt;T&gt; pointers</span>
<span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">thread</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// private. cleans up any dead pointers in a pool</span>
    <span class="k">fn</span> <span class="nf">cleanup</span><span class="p">(</span><span class="n">pool</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pool</span><span class="nf">.retain</span><span class="p">(|</span><span class="n">e</span><span class="p">:</span> <span class="o">&amp;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">true</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">false</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pool</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c">// create a closure which will become a new thread</span>
        <span class="k">let</span> <span class="n">gc</span> <span class="o">=</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">loop</span> <span class="p">{</span>
                <span class="nn">GC</span><span class="p">::</span><span class="nf">cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">pool</span><span class="p">);</span>

                <span class="c">// wait for 100 milliseconds, then scan again</span>
                <span class="k">let</span> <span class="n">sleep</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
                <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">sleep</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="c">// spawns a new thread and returns a handle to the thread</span>
        <span class="k">let</span> <span class="n">gc_thread</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>

        <span class="n">GC</span> <span class="p">{</span>
            <span class="n">pool</span><span class="p">:</span>   <span class="n">pool</span><span class="p">,</span>
            <span class="n">thread</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">gc_thread</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">track</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.pool</span><span class="nf">.push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nf">sync_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">rt</span> <span class="o">=</span> <span class="nn">RealtimeThread</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">ui</span> <span class="o">=</span> <span class="nn">UIThread</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">tx</span><span class="p">);</span>
    <span class="nf">run_threads</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We’ve written a bunch of new code, better make sure it compiles (<a href="https://play.rust-lang.org/?gist=0740c7896b0dd8c37e1d57aa9e53ca0b&amp;version=stable&amp;backtrace=0">Rust playground</a>):</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]:</span> <span class="n">the</span> <span class="k">trait</span> <span class="n">bound</span> <span class="err">`</span><span class="n">T</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Send</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">satisfied</span>
   <span class="err">-</span><span class="k">-&gt;</span> <span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">154</span><span class="p">:</span><span class="mi">25</span>
    <span class="p">|</span>
<span class="mi">154</span> <span class="p">|</span>         <span class="k">let</span> <span class="n">gc_thread</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>
    <span class="p">|</span>                         <span class="o">^^^^^^^^^^^^^</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Send</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="err">`</span><span class="n">T</span><span class="err">`</span>
    <span class="p">|</span>
    <span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">adding</span> <span class="n">a</span> <span class="err">`</span><span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Send</span><span class="err">`</span> <span class="n">bound</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">of</span> <span class="n">the</span> <span class="n">requirements</span> <span class="n">on</span> <span class="n">the</span> <span class="k">impl</span> <span class="n">of</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Send</span><span class="err">`</span> <span class="k">for</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">of</span> <span class="n">the</span> <span class="n">requirements</span> <span class="n">on</span> <span class="n">the</span> <span class="k">impl</span> <span class="n">of</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Send</span><span class="err">`</span> <span class="k">for</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="n">Unique</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">it</span> <span class="n">appears</span> <span class="n">within</span> <span class="n">the</span> <span class="k">type</span> <span class="err">`</span><span class="nn">alloc</span><span class="p">::</span><span class="nn">raw_vec</span><span class="p">::</span><span class="n">RawVec</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">it</span> <span class="n">appears</span> <span class="n">within</span> <span class="n">the</span> <span class="k">type</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">of</span> <span class="n">the</span> <span class="n">requirements</span> <span class="n">on</span> <span class="n">the</span> <span class="k">impl</span> <span class="n">of</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Send</span><span class="err">`</span> <span class="k">for</span> <span class="err">`</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">it</span> <span class="n">appears</span> <span class="n">within</span> <span class="n">the</span> <span class="k">type</span> <span class="err">`</span><span class="p">[</span><span class="n">closure</span><span class="o">@&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">143</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span> <span class="mi">151</span><span class="p">:</span><span class="mi">10</span> <span class="n">pool</span><span class="p">:</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">]</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">by</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="n">spawn</span><span class="err">`</span>

<span class="n">error</span><span class="p">[</span><span class="n">E0277</span><span class="p">]:</span> <span class="n">the</span> <span class="k">trait</span> <span class="n">bound</span> <span class="err">`</span><span class="n">T</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="n">Sync</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">satisfied</span>
   <span class="err">-</span><span class="k">-&gt;</span> <span class="o">&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">154</span><span class="p">:</span><span class="mi">25</span>
    <span class="p">|</span>
<span class="mi">154</span> <span class="p">|</span>         <span class="k">let</span> <span class="n">gc_thread</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>
    <span class="p">|</span>                         <span class="o">^^^^^^^^^^^^^</span> <span class="n">the</span> <span class="k">trait</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="n">Sync</span><span class="err">`</span> <span class="n">is</span> <span class="n">not</span> <span class="n">implemented</span> <span class="k">for</span> <span class="err">`</span><span class="n">T</span><span class="err">`</span>
    <span class="p">|</span>
    <span class="o">=</span> <span class="n">help</span><span class="p">:</span> <span class="n">consider</span> <span class="n">adding</span> <span class="n">a</span> <span class="err">`</span><span class="k">where</span> <span class="n">T</span><span class="p">:</span> <span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="n">Sync</span><span class="err">`</span> <span class="n">bound</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">of</span> <span class="n">the</span> <span class="n">requirements</span> <span class="n">on</span> <span class="n">the</span> <span class="k">impl</span> <span class="n">of</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Send</span><span class="err">`</span> <span class="k">for</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">of</span> <span class="n">the</span> <span class="n">requirements</span> <span class="n">on</span> <span class="n">the</span> <span class="k">impl</span> <span class="n">of</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Send</span><span class="err">`</span> <span class="k">for</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">ptr</span><span class="p">::</span><span class="n">Unique</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">it</span> <span class="n">appears</span> <span class="n">within</span> <span class="n">the</span> <span class="k">type</span> <span class="err">`</span><span class="nn">alloc</span><span class="p">::</span><span class="nn">raw_vec</span><span class="p">::</span><span class="n">RawVec</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">it</span> <span class="n">appears</span> <span class="n">within</span> <span class="n">the</span> <span class="k">type</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">of</span> <span class="n">the</span> <span class="n">requirements</span> <span class="n">on</span> <span class="n">the</span> <span class="k">impl</span> <span class="n">of</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">marker</span><span class="p">::</span><span class="nb">Send</span><span class="err">`</span> <span class="k">for</span> <span class="err">`</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">because</span> <span class="n">it</span> <span class="n">appears</span> <span class="n">within</span> <span class="n">the</span> <span class="k">type</span> <span class="err">`</span><span class="p">[</span><span class="n">closure</span><span class="o">@&lt;</span><span class="n">anon</span><span class="o">&gt;</span><span class="p">:</span><span class="mi">143</span><span class="p">:</span><span class="mi">18</span><span class="p">:</span> <span class="mi">151</span><span class="p">:</span><span class="mi">10</span> <span class="n">pool</span><span class="p">:</span><span class="o">&amp;</span><span class="k">mut</span> <span class="nn">std</span><span class="p">::</span><span class="nn">vec</span><span class="p">::</span><span class="nb">Vec</span><span class="o">&lt;</span><span class="nn">std</span><span class="p">::</span><span class="nn">sync</span><span class="p">::</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">]</span><span class="err">`</span>
    <span class="o">=</span> <span class="n">note</span><span class="p">:</span> <span class="n">required</span> <span class="n">by</span> <span class="err">`</span><span class="nn">std</span><span class="p">::</span><span class="nn">thread</span><span class="p">::</span><span class="n">spawn</span><span class="err">`</span>

<span class="n">error</span><span class="p">:</span> <span class="n">aborting</span> <span class="n">due</span> <span class="n">to</span> <span class="mi">2</span> <span class="n">previous</span> <span class="n">errors</span>
</code></pre></div></div>

<p>Oops, this isn’t good.
This error makes it feel sort of like Rust hates us, but the compiler is actually doing us a massive favor.</p>

<p>In Rust, there are a few thread safety “marker traits” called <code class="highlighter-rouge">Send</code> and <code class="highlighter-rouge">Sync</code>.
The compiler is telling us that our generic type <code class="highlighter-rouge">T</code> doesn’t implement either of them.</p>

<p>Put very loosely, if something implements <code class="highlighter-rouge">Send</code>, it is safe to send it between threads.
<code class="highlighter-rouge">Sync</code> is considerably more subtle and quite difficult to wrap your head around, but we can sort of say that, if something implements <code class="highlighter-rouge">Sync</code>, we can <em>access</em> the same instance of it from multiple threads.
For more info, you can read <a href="http://huonw.github.io/blog/2015/02/some-notes-on-send-and-sync/">this blog post</a>, but you shouldn’t need any more than what I’ve given to get through the rest of my post.</p>

<p>So anyway, Rust is telling us that we have a thread safety problem, but we haven’t guaranteed that we can safely copy and access values of our type <code class="highlighter-rouge">T</code> between the garbage collector thread and any other threads.</p>

<p>I know that <code class="highlighter-rouge">T</code> must be <code class="highlighter-rouge">Send</code>, because it has to be sent between threads, so let’s go ahead and add that restriction:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// A garbage collector for Arc&lt;T&gt; pointers</span>
<span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">thread</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span><span class="o">&gt;</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="c">// ....</span>
</code></pre></div></div>

<p><a href="https://play.rust-lang.org/?gist=4f718d3a1795409d67894a8f4f86f010&amp;version=stable&amp;backtrace=0">Rust playground link</a></p>

<p>Hoorary, the <code class="highlighter-rouge">Send</code> error is gone!
Unfortunately, we still have the issue with <code class="highlighter-rouge">Sync</code>.
Let’s look more closely at the error we are getting:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0277]: the trait bound `T: std::marker::Sync` is not satisfied
   --&gt; &lt;anon&gt;:154:25
    |
154 |         let gc_thread = thread::spawn(gc);
    |                         ^^^^^^^^^^^^^ the trait `std::marker::Sync` is not implemented for `T`
    |
    = help: consider adding a `where T: std::marker::Sync` bound
    = note: required because of the requirements on the impl of `std::marker::Send` for `std::sync::Arc&lt;T&gt;`
    = note: required because of the requirements on the impl of `std::marker::Send` for `std::ptr::Unique&lt;std::sync::Arc&lt;T&gt;&gt;`
    = note: required because it appears within the type `alloc::raw_vec::RawVec&lt;std::sync::Arc&lt;T&gt;&gt;`
    = note: required because it appears within the type `std::vec::Vec&lt;std::sync::Arc&lt;T&gt;&gt;`
    = note: required because of the requirements on the impl of `std::marker::Send` for `&amp;mut std::vec::Vec&lt;std::sync::Arc&lt;T&gt;&gt;`
    = note: required because it appears within the type `[closure@&lt;anon&gt;:143:18: 151:10 pool:&amp;mut std::vec::Vec&lt;std::sync::Arc&lt;T&gt;&gt;]`
    = note: required by `std::thread::spawn`

error: aborting due to previous error
</code></pre></div></div>

<p>This error is really confusing, and my solution for it is not going to be much better, but stick with me.</p>

<p>The origin of this error is the <code class="highlighter-rouge">Arc&lt;T&gt;</code>.
If we want an <code class="highlighter-rouge">Arc&lt;T&gt;</code> to implement <code class="highlighter-rouge">Send</code>, the <code class="highlighter-rouge">T</code> contained in it must implement BOTH <code class="highlighter-rouge">Send</code> and <code class="highlighter-rouge">Sync</code>.
It makes sense that <code class="highlighter-rouge">T</code> would need to implement <code class="highlighter-rouge">Send</code>, but why does <code class="highlighter-rouge">T</code> need to be <code class="highlighter-rouge">Sync</code>?
Basically, this is because the data the <code class="highlighter-rouge">Arc&lt;T&gt;</code> is holding will be shared by anyone who can access the <code class="highlighter-rouge">Arc&lt;T&gt;</code>.
An <code class="highlighter-rouge">Arc</code> can be <code class="highlighter-rouge">clone</code>ed at any time, so, if we are allowed to pass it to other threads, it must also be safe for multiple threads to access the underlying data at the same time.</p>

<p>We could add the <code class="highlighter-rouge">Sync</code> constraint to our type <code class="highlighter-rouge">T</code> to resolve this problem, but does this really make any sense?
Nowhere in our application will a message be accessible by more than one thread at a time.</p>

<p>When the UI thread creates a new message, it immediately surrenders all access to the underlying data, by moving the value into the channel.
Once the realtime thread has the data, it will be the only thread that actually accesses the data until the data needs to be freed.
The GC also is holding a reference to data, but it will never actually touch the data in any way, until it frees it.
When the GC thread frees the memory holding the data, we know that there will be no other references to the memory in the program.</p>

<p>I might be wrong about this (please let me know if I am), but I think that we don’t actually <em>need</em> the type <code class="highlighter-rouge">T</code> to be <code class="highlighter-rouge">Sync</code>.
The compiler will never let us get away with this (because it doesn’t know all of these properties) but we can let it know that it should trust us, with a new struct:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">TrustMe</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">pub</span> <span class="n">inner</span><span class="p">:</span> <span class="n">T</span>
<span class="p">}</span>

<span class="k">unsafe</span> <span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="nb">Send</span> <span class="k">for</span> <span class="n">TrustMe</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{}</span>
</code></pre></div></div>

<p>This will tell the compiler “yes, this thing is <code class="highlighter-rouge">Send</code>”, even when it actually isn’t, so the implementation of the trait <code class="highlighter-rouge">Send</code> is unsafe.</p>

<p>Now, we can create a <code class="highlighter-rouge">Send</code>able <code class="highlighter-rouge">TrustMe&lt;Arc&lt;T&gt;&gt;</code>, and the compiler will trust us when we share these <code class="highlighter-rouge">Arc&lt;T&gt;</code>s between threads.</p>

<p>Now, lets add this to our GC:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// A garbage collector for Arc&lt;T&gt; pointers</span>
<span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">:</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TrustMe</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">thread</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span><span class="o">&gt;</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// private. cleans up any dead pointers in a pool</span>
    <span class="k">fn</span> <span class="nf">cleanup</span><span class="p">(</span><span class="n">pool</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TrustMe</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">pool</span><span class="nf">.retain</span><span class="p">(|</span><span class="n">e</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrustMe</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">|</span> <span class="p">{</span>
            <span class="k">if</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="py">.inner</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">true</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="k">return</span> <span class="k">false</span>
            <span class="p">}</span>
        <span class="p">});</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">pool</span> <span class="o">=</span> <span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

        <span class="c">// create a closure which will become a new thread</span>
        <span class="k">let</span> <span class="n">gc</span> <span class="o">=</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">loop</span> <span class="p">{</span>
                <span class="nn">GC</span><span class="p">::</span><span class="nf">cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">pool</span><span class="p">);</span>

                <span class="c">// wait for 100 milliseconds, then scan again</span>
                <span class="k">let</span> <span class="n">sleep</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
                <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">sleep</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">};</span>

        <span class="c">// spawns a new thread and returns a handle to the thread</span>
        <span class="k">let</span> <span class="n">gc_thread</span> <span class="o">=</span> <span class="nn">thread</span><span class="p">::</span><span class="nf">spawn</span><span class="p">(</span><span class="n">gc</span><span class="p">);</span>

        <span class="n">GC</span> <span class="p">{</span>
            <span class="n">pool</span><span class="p">:</span>   <span class="n">pool</span><span class="p">,</span>
            <span class="n">thread</span><span class="p">:</span> <span class="nf">Some</span><span class="p">(</span><span class="n">gc_thread</span><span class="p">),</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">track</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">TrustMe</span> <span class="p">{</span> <span class="n">inner</span><span class="p">:</span> <span class="n">t</span> <span class="p">};</span>
        <span class="k">self</span><span class="py">.pool</span><span class="nf">.push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p><a href="https://play.rust-lang.org/?gist=b23d5e7a7541eda3096daac685d309bf&amp;version=stable&amp;backtrace=0">Rust Playground Link</a></p>

<p>When we try to compile this, we get YET ANOTHER compiler error.
This time, the compiler is whining at us with “the parameter type <code class="highlighter-rouge">T</code> may not live long enough”.
This error message is frustrating, but, we are using Rust because we want to be very careful with memory safety, so lets try to keep going.</p>

<p>The new thread that we have created could run until the termination of the program, so any data which the thread might be holding onto also must be able to live until the termination of the program.</p>

<p>The compiler is telling us that we need to add a “lifetime specifier” to our type <code class="highlighter-rouge">T</code>.
In this case, it is telling us that the lifetime of any <code class="highlighter-rouge">T</code> which is managed by the GC must be <code class="highlighter-rouge">'static</code>.
The <code class="highlighter-rouge">'static</code> lifetime indicates that values of type <code class="highlighter-rouge">T + 'static</code> <em>might</em> live for the entire duration of the program.</p>

<p>This might seem excessive, but, it is not possible for the compiler to determine when in the program our thread will terminate (if it could we would have solved the halting problem), so the maximum lifetime MUST potentially be the entire duration of the program.
Note that, this doesn’t mean that all the values stored in the GC will necessarily live for the entire lifetime of the program (if they did, we wouldn’t be cleaning up garbage).
This condition just means that they might live that long.</p>

<p>Anyway, we can now add the <code class="highlighter-rouge">+ 'static</code> specifier the compiler has asked us to add, and try to compile this one more time.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// A garbage collector for Arc&lt;T&gt; pointers</span>
<span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nv">'static</span><span class="o">&gt;</span> <span class="p">{</span>

<span class="c">// ...</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nv">'static</span><span class="o">&gt;</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>

<span class="c">// ...</span>
</code></pre></div></div>

<p>GUESS WHAT IT DIDN’T WORK.</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>error[E0373]: closure may outlive the current function, but it borrows `pool`, which is owned by the current function
   --&gt; &lt;anon&gt;:149:18
    |
149 |         let gc = || {
    |                  ^^ may outlive borrowed value `pool`
150 |             loop {
151 |                 GC::cleanup(&amp;mut pool);
    |                                  ---- `pool` is borrowed here
    |
help: to force the closure to take ownership of `pool` (and any other referenced variables), use the `move` keyword, as shown:
    |         let gc = move || {

error: aborting due to previous error
</code></pre></div></div>

<p>Once again, this is a good thing, I promise!
Now, the compiler is trying to tell us that the vector named <code class="highlighter-rouge">pool</code> is being accessed from two different places.
The compiler wants us to have the new thread take ownership of the vector, but this highlights an interesting problem.
We need to allow both the GC thread, and any other non-realtime thread, to access the vector, at the same time.</p>

<p>The compiler has prevented us from accessing the same data from multiple threads.</p>

<p>To solve this, we can just wrap the vector in a <code class="highlighter-rouge">Mutex</code> <strong>and</strong> an <code class="highlighter-rouge">Arc</code>.
The <code class="highlighter-rouge">Arc</code> allows us to create one instance of the vector on the heap, and the <code class="highlighter-rouge">Mutex</code> makes sure that only one thread can access the heap allocated vector at any given time.</p>

<p>Here are most of the changes:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// introduce some news type aliases to make life a little bit easier</span>
<span class="k">type</span> <span class="n">TrustedArc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="n">TrustMe</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="k">type</span> <span class="n">ArcPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TrustedArc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>

<span class="c">/// A garbage collector for Arc&lt;T&gt; pointers</span>
<span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nv">'static</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">:</span> <span class="n">Mutex</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">ArcPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">thread</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// ...</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nv">'static</span><span class="o">&gt;</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="c">// ...</span>
    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">new</span><span class="p">()</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">pool</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Mutex</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="nn">Vec</span><span class="p">::</span><span class="nf">new</span><span class="p">()));</span>

        <span class="c">// create a copy of the pool. The GC thread will own this clone</span>
        <span class="c">// and the reference count will be incremented by one</span>
        <span class="k">let</span> <span class="n">thread_arc_copy</span> <span class="o">=</span> <span class="n">pool</span><span class="nf">.clone</span><span class="p">();</span>

        <span class="c">// create a closure which will become a new thread</span>
        <span class="k">let</span> <span class="n">gc</span> <span class="o">=</span> <span class="k">move</span> <span class="p">||</span> <span class="p">{</span>
            <span class="k">loop</span> <span class="p">{</span>
                <span class="c">// lock the mutex, then let go of it.</span>
                <span class="c">// If we hold the mutex, the UI thread will be blocked every time it asks the</span>
                <span class="c">// collector to track something.</span>
                <span class="p">{</span>
                    <span class="k">let</span> <span class="k">mut</span> <span class="n">pool</span> <span class="o">=</span> <span class="n">thread_arc_copy</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
                    <span class="nn">GC</span><span class="p">::</span><span class="nf">cleanup</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="n">pool</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="c">// wait for a bit, then scan again</span>
                <span class="k">let</span> <span class="n">sleep</span> <span class="o">=</span> <span class="nn">std</span><span class="p">::</span><span class="nn">time</span><span class="p">::</span><span class="nn">Duration</span><span class="p">::</span><span class="nf">from_millis</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
                <span class="nn">thread</span><span class="p">::</span><span class="nf">sleep</span><span class="p">(</span><span class="n">sleep</span><span class="p">);</span>

            <span class="p">}</span>
        <span class="p">};</span>

        <span class="c">// ....</span>
    <span class="p">}</span>

    <span class="k">pub</span> <span class="k">fn</span> <span class="nf">track</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">,</span> <span class="n">t</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">let</span> <span class="n">t</span> <span class="o">=</span> <span class="n">TrustMe</span> <span class="p">{</span> <span class="n">inner</span><span class="p">:</span> <span class="n">t</span> <span class="p">};</span>
        <span class="k">let</span> <span class="k">mut</span> <span class="n">pool</span> <span class="o">=</span> <span class="k">self</span><span class="py">.pool</span><span class="nf">.lock</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="n">pool</span><span class="nf">.push</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We can finally compile this!
Here’s a link to the <a href="https://play.rust-lang.org/?gist=7f41622e104d07f9b106495c2a5373a7&amp;version=nightly&amp;backtrace=0">Rust playground</a>.
Note that you will need to make sure you compile with the “Nightly” channel.</p>

<p>There are only a few things left to do.</p>

<h2 id="start-and-stop-the-gc">Start and Stop the GC</h2>
<p>The GC thread that we have created will never terminate.</p>

<p>Ideally, when the GC goes out of scope, it will shut down the GC thread and clean up any tracked memory (if it can).
Any <code class="highlighter-rouge">Arc</code>s which can’t be freed when the GC is shut down will not be freed, but (this is important) the reference count will drop by one.
Now, if one of the previously tracked <code class="highlighter-rouge">Arc</code>s goes out of scope, it will be freed on whatever thread drops it (this could be the realtime thread!)</p>

<p>So, as long as the realtime thread keeps running, we must keep the GC thread running.</p>

<p>First, edit main:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">fn</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c">// start the collector</span>
    <span class="k">let</span> <span class="n">collector</span> <span class="o">=</span> <span class="nn">GC</span><span class="p">::</span><span class="nf">new</span><span class="p">();</span>

    <span class="c">// create the channels</span>
    <span class="k">let</span> <span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">rx</span><span class="p">)</span> <span class="o">=</span> <span class="nn">mpsc</span><span class="p">::</span><span class="nf">sync_channel</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="c">// set up both of the threads</span>
    <span class="k">let</span> <span class="n">rt</span> <span class="o">=</span> <span class="nn">RealtimeThread</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">rx</span><span class="p">);</span>
    <span class="k">let</span> <span class="n">ui</span> <span class="o">=</span> <span class="nn">UIThread</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="n">tx</span><span class="p">);</span>

    <span class="c">// start the threads</span>
    <span class="nf">run_threads</span><span class="p">(</span><span class="n">rt</span><span class="p">,</span> <span class="n">ui</span><span class="p">);</span>

    <span class="c">// GC thread will be shutdown here, where the GC goes out of scope</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Then, edit the <code class="highlighter-rouge">UIThread</code> struct appropriately.</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>
<span class="k">struct</span> <span class="n">UIThread</span> <span class="p">{</span>
    <span class="n">outgoing</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">SyncSender</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">,</span>
    <span class="n">collector</span><span class="p">:</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">Samples</span><span class="o">&gt;</span>
<span class="p">}</span>

<span class="k">impl</span> <span class="n">UIThread</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="nf">new</span><span class="p">(</span><span class="n">outgoing</span><span class="p">:</span> <span class="nn">mpsc</span><span class="p">::</span><span class="n">SyncSender</span><span class="o">&lt;</span><span class="n">Message</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">collector</span><span class="p">:</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">Samples</span><span class="o">&gt;</span><span class="p">)</span> <span class="k">-&gt;</span> <span class="n">Self</span> <span class="p">{</span>
        <span class="n">UIThread</span> <span class="p">{</span> <span class="n">outgoing</span><span class="p">:</span> <span class="n">outgoing</span><span class="p">,</span> <span class="n">collector</span><span class="p">:</span> <span class="n">collector</span> <span class="p">}</span>
    <span class="p">}</span>

    <span class="c">// ...</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Next, update the <code class="highlighter-rouge">UIThread::run</code> method:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c">/// All of the UI thread code</span>
    <span class="k">fn</span> <span class="nf">run</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="c">// create 5 "ui events"</span>
        <span class="k">for</span> <span class="n">i</span> <span class="n">in</span> <span class="mi">0</span><span class="o">..</span><span class="mi">5</span> <span class="p">{</span>
            <span class="k">let</span> <span class="n">volume</span> <span class="o">=</span> <span class="n">i</span> <span class="k">as</span> <span class="nb">f32</span> <span class="err">/</span> <span class="mf">5.0</span><span class="p">;</span>
            <span class="k">let</span> <span class="n">samples</span> <span class="o">=</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">new</span><span class="p">(</span><span class="k">self</span><span class="nf">.compute_samples</span><span class="p">(</span><span class="n">volume</span><span class="p">));</span>

            <span class="c">// tell the GC thread to track our list of samples</span>
            <span class="k">self</span><span class="py">.collector</span><span class="nf">.track</span><span class="p">(</span><span class="n">samples</span><span class="nf">.clone</span><span class="p">());</span>

            <span class="c">// send the samples to the other thread</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"[ui] sending new samples. Second sample: {}"</span><span class="p">,</span> <span class="n">samples</span><span class="p">[</span><span class="mi">1</span><span class="p">]);</span>
            <span class="k">self</span><span class="py">.outgoing</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Message</span><span class="p">::</span><span class="nf">NewSamples</span><span class="p">(</span><span class="n">samples</span><span class="p">))</span><span class="nf">.unwrap</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="c">// tell the other thread to shutdown</span>
        <span class="k">self</span><span class="py">.outgoing</span><span class="nf">.send</span><span class="p">(</span><span class="nn">Message</span><span class="p">::</span><span class="n">Shutdown</span><span class="p">)</span><span class="nf">.unwrap</span><span class="p">();</span>
    <span class="p">}</span>
</code></pre></div></div>

<h2 id="drop-the-gc">Drop the GC</h2>

<p>Rust will make sure that <code class="highlighter-rouge">Drop</code> is called when the struct goes out of scope.
This gives us a change to shut down the GC thread.
We also set up a shared atomic boolean to indicate when the GC thread should shut down.</p>

<p>Here is most of that:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">/// A garbage collector for Arc&lt;T&gt; pointers</span>
<span class="k">struct</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nv">'static</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="n">pool</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">Mutex</span><span class="o">&lt;</span><span class="n">ArcPool</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">,</span>
    <span class="n">thread</span><span class="p">:</span> <span class="nb">Option</span><span class="o">&lt;</span><span class="nn">thread</span><span class="p">::</span><span class="n">JoinHandle</span><span class="o">&lt;</span><span class="p">()</span><span class="o">&gt;&gt;</span><span class="p">,</span>
    <span class="n">running</span><span class="p">:</span> <span class="nb">Arc</span><span class="o">&lt;</span><span class="n">AtomicBool</span><span class="o">&gt;</span><span class="p">,</span>
<span class="p">}</span>

<span class="c">// initialize the running flag to false in GC::new</span>

<span class="c">// ....</span>

<span class="k">impl</span><span class="o">&lt;</span><span class="n">T</span><span class="p">:</span> <span class="nb">Send</span> <span class="o">+</span> <span class="nv">'static</span><span class="o">&gt;</span> <span class="n">Drop</span> <span class="k">for</span> <span class="n">GC</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="p">{</span>
    <span class="k">fn</span> <span class="k">drop</span><span class="p">(</span><span class="o">&amp;</span><span class="k">mut</span> <span class="k">self</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">self</span><span class="py">.running</span><span class="nf">.store</span><span class="p">(</span><span class="k">false</span><span class="p">,</span> <span class="nn">Ordering</span><span class="p">::</span><span class="n">Relaxed</span><span class="p">);</span>
        <span class="k">match</span> <span class="k">self</span><span class="py">.thread</span><span class="nf">.take</span><span class="p">()</span> <span class="p">{</span>
            <span class="nf">Some</span><span class="p">(</span><span class="n">t</span><span class="p">)</span> <span class="k">=&gt;</span> <span class="n">t</span><span class="nf">.join</span><span class="p">()</span><span class="nf">.unwrap</span><span class="p">(),</span>
            <span class="nb">None</span>    <span class="k">=&gt;</span> <span class="p">()</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And, here’s the <a href="https://play.rust-lang.org/?gist=c33dec5b9aad44864035de4c81c1f492&amp;version=nightly&amp;backtrace=0">Rust playground link</a>.
You may have some trouble getting this to run (timeouts occur), but I promise it works sometimes.</p>

<p>Example output:</p>

<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[realtime] thread started
[ui] thread started
[ui] sending new samples. Second sample: 0
[ui] sending new samples. Second sample: 0.01960343
[realtime] received new samples. Second sample: 0
[ui] sending new samples. Second sample: 0.03920686
[realtime] received new samples. Second sample: 0.01960343
[realtime] received new samples. Second sample: 0.03920686
[ui] thread shutting down
[realtime] thread shutting down
</code></pre></div></div>

<h2 id="proof">Proof</h2>
<p>Let’s add some logging so we can see when things are getting freed:</p>

<div class="language-rust highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">// private. cleans up any dead pointers in a pool</span>
<span class="k">fn</span> <span class="nf">cleanup</span><span class="p">(</span><span class="n">pool</span><span class="p">:</span> <span class="o">&amp;</span><span class="k">mut</span> <span class="nb">Vec</span><span class="o">&lt;</span><span class="n">TrustMe</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;&gt;</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">pool</span><span class="nf">.retain</span><span class="p">(|</span><span class="n">e</span><span class="p">:</span> <span class="o">&amp;</span><span class="n">TrustMe</span><span class="o">&lt;</span><span class="nb">Arc</span><span class="o">&lt;</span><span class="n">_</span><span class="o">&gt;&gt;</span><span class="p">|</span> <span class="p">{</span>
        <span class="k">if</span> <span class="nn">Arc</span><span class="p">::</span><span class="nf">strong_count</span><span class="p">(</span><span class="o">&amp;</span><span class="n">e</span><span class="py">.inner</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="p">{</span>
            <span class="k">return</span> <span class="k">true</span>
        <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="nd">println!</span><span class="p">(</span><span class="s">"[gc] dropping a value!"</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">false</span>
        <span class="p">}</span>
    <span class="p">});</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The completed code lives at <a href="https://play.rust-lang.org/?gist=7c48a9e595463cb4b8a2c155feb50234&amp;version=nightly&amp;backtrace=0">this Rust playground link</a>.</p>

<p>Example Output:</p>
<div class="highlighter-rouge"><div class="highlight"><pre class="highlight"><code>[realtime] thread started
[ui] thread started
[ui] sending new samples. Second sample: 0
[realtime] received new samples. Second sample: 0
[ui] sending new samples. Second sample: 0.01960343
[realtime] received new samples. Second sample: 0.01960343
[gc] dropping a value!
[ui] sending new samples. Second sample: 0.03920686
[realtime] received new samples. Second sample: 0.03920686
[gc] dropping a value!
[ui] sending new samples. Second sample: 0.058810286
[realtime] received new samples. Second sample: 0.058810286
[gc] dropping a value!
[ui] sending new samples. Second sample: 0.07841372
[realtime] received new samples. Second sample: 0.07841372
[gc] dropping a value!
[ui] thread shutting down
[realtime] thread shutting down
</code></pre></div></div>

<h1 id="conclusion">Conclusion</h1>
<p>We did it!</p>

<p>For me, this post exemplifies the reasons I am so excited about Rust.
The realtime audio world places us into a world where many programming languages are simply not usable.
Languages with runtimes that may behave unpredictably cannot meet the extremely strict requirements we must meet for correct realtime operation.
Rust allows us to meet all of those requirements and gives us some nice abstractions.</p>

<p>On top of that, the Rust compiler meticulously checks for thread safety violations and memory safety violations.
While writing this post, some of the issues the compiler threw at me (<code class="highlighter-rouge">'static</code>, for example), are issues I never considered.
The compiler caught me and told me “no,” so I had to think about what was actually going on.</p>

<p>These checks are absolutely irritating, and sometimes we might want to work around them (like we did with <code class="highlighter-rouge">TrustMe</code>).
I’m glad to be exposed to potential issues, even if I have to work around the compiler sometimes (so far).</p>

<p>If you made it this far, thank you for reading.
I hope you’ve learned something interesting (maybe even useful).</p>

<p>Discussion on <a href="https://www.reddit.com/r/rust/comments/5qxqo8/show_and_ask_rrust_garbage_collection_for_rust/">reddit</a>.</p>

</article>







      </div>
    </div>
  </div>

  <footer class="footer">
  <div class="p2 wrap">
    <div class="measure mt1 center">
      <small>
        Theme crafted with &lt;3 by <a href="http://johnotander.com">John Otander</a> (<a href="https://twitter.com/4lpine">@4lpine</a>).<br>
      </small>
    </div>
  </div>
</footer>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-40842690-1', 'auto');
ga('send', 'pageview');

</script>


<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</body>
</html>
