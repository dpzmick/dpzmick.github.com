<!DOCTYPE html>
<html>
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <title>Outsmarting the compiler &#8211; dpzmick.com</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="description" content="Just some dude's blog">
    <meta name="author" content="David Zmick">
    <meta name="keywords" content="">
    <link rel="canonical" href="http://dpzmick.com/2017/05/25/outsmarting-the-compiler/">

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/pixyll.css" type="text/css">

    <!-- MathJax config -->
    <script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        extensions: ["tex2jax.js"],
        jax:        ["input/TeX", "output/HTML-CSS"],
        tex2jax:    {
            inlineMath: [ ['$','$'], ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"] ],
            processEscapes: true
        },
        "HTML-CSS": {
             availableFonts:
             ["TeX"]
        }
    });
    </script>

    <!-- Fonts -->
    <link href='//fonts.googleapis.com/css?family=Merriweather:900,900italic,300,300italic' rel='stylesheet' type='text/css'>
    <link href='//fonts.googleapis.com/css?family=Lato:900,300' rel='stylesheet' type='text/css'>
    
      <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.2.0/css/font-awesome.min.css" rel="stylesheet">
    

    <!-- Open Graph -->
    <!-- From: https://github.com/mmistakes/hpstr-jekyll-theme/blob/master/_includes/head.html -->
    <meta property="og:locale" content="en_US">
    <meta property="og:type" content="article">
    <meta property="og:title" content="Outsmarting the compiler">
    <meta property="og:description" content="Can you?">
    <meta property="og:url" content="http://dpzmick.com/2017/05/25/outsmarting-the-compiler/">
    <meta property="og:site_name" content="dpzmick.com">

    <!-- Icons -->
    <link rel="apple-touch-icon" sizes="57x57" href="apple-touch-icon-57x57.png">
    <link rel="apple-touch-icon" sizes="114x114" href="apple-touch-icon-114x114.png">
    <link rel="apple-touch-icon" sizes="72x72" href="apple-touch-icon-72x72.png">
    <link rel="apple-touch-icon" sizes="144x144" href="apple-touch-icon-144x144.png">
    <link rel="apple-touch-icon" sizes="60x60" href="apple-touch-icon-60x60.png">
    <link rel="apple-touch-icon" sizes="120x120" href="apple-touch-icon-120x120.png">
    <link rel="apple-touch-icon" sizes="76x76" href="apple-touch-icon-76x76.png">
    <link rel="apple-touch-icon" sizes="152x152" href="apple-touch-icon-152x152.png">
    <link rel="apple-touch-icon" sizes="180x180" href="apple-touch-icon-180x180.png">
    <link rel="icon" type="image/png" href="favicon-192x192.png" sizes="192x192">
    <link rel="icon" type="image/png" href="favicon-160x160.png" sizes="160x160">
    <link rel="icon" type="image/png" href="favicon-96x96.png" sizes="96x96">
    <link rel="icon" type="image/png" href="favicon-16x16.png" sizes="16x16">
    <link rel="icon" type="image/png" href="favicon-32x32.png" sizes="32x32">
</head>

<body class="">
  <div class="site-wrap">
    <header class="site-header px2 px-responsive">
  <div class="mt2 wrap">
    <div class="measure">
      <a href="http://dpzmick.com" class="site-title">dpzmick.com</a>
      <nav class="site-nav right">
        <a href="/about/">About</a>
<!-- don't highlight that I never finish anything -->
<!-- <a href="/series/">Blog Series</a> -->
<a href="https://www.youtube.com/channel/UCYkk_c66qufhHQBpM5wwLaQ">Synthesizer</a>
<a href="http://dpzmick.com/resume/resume.pdf">Resume</a>

      </nav>
      <div class="clearfix"></div>
      
        <div class="social-icons">
  <div class="left">
    
      <a class="fa fa-github" href="https://github.com/dpzmick"></a>
    
    
    <a class="fa fa-rss" href="/feed.xml"></a>
    
    

    
      <a class="fa fa-linkedin" href="https://www.linkedin.com/in/dpzmick"></a>
    
  </div>
  <div class="right">
    
    
    
  </div>
</div>
<div class="clearfix"></div>

      
    </div>
  </div>
</header>


    <div class="post p2 p-responsive wrap" role="main">
      <div class="measure">
        <div class="post-header mb2">
  <h1>Outsmarting the compiler</h1>
  <span class="post-meta">May 25, 2017</span><br>
  
</div>

<article class="post-content">
  <p>Suppose we have two very similar structs which we need to partially populate “ahead of time” and store somewhere.
Then, a bit later, we need to <strong>very quickly</strong> finish populating the structs.
Here are some example structs:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">A</span> <span class="p">{</span>
  <span class="kt">int64_t</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">char</span>    <span class="n">arr</span><span class="p">[</span><span class="n">PADDING1</span><span class="p">];</span>
  <span class="kt">int64_t</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">__attribute__</span><span class="p">((</span><span class="n">packed</span><span class="p">))</span> <span class="n">B</span> <span class="p">{</span>
  <span class="kt">int64_t</span> <span class="n">a</span><span class="p">;</span>
  <span class="kt">int64_t</span> <span class="n">b</span><span class="p">;</span>
  <span class="kt">char</span>    <span class="n">arr</span><span class="p">[</span><span class="n">PADDING2</span><span class="p">];</span>
  <span class="kt">int64_t</span> <span class="n">c</span><span class="p">;</span>
<span class="p">};</span>
</code></pre>
</div>

<p>The “padding” arrays are populated ahead of time, so we just need to set <code class="highlighter-rouge">a</code>, <code class="highlighter-rouge">b</code>, and <code class="highlighter-rouge">c</code> for each struct (quickly):</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">writeFields</span><span class="p">(</span><span class="n">T</span><span class="o">*</span> <span class="n">t</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">c</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Unfortunately, we don’t statically know what struct we are going to have to operate on; we only get this information at runtime.
We just have a blob of memory and a tag which indicates which of the two variants of the struct is sitting in the blob of memory:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Variant</span> <span class="p">{</span> <span class="n">eA</span><span class="p">,</span> <span class="n">eB</span> <span class="p">};</span>

<span class="k">struct</span> <span class="n">Wrapper</span> <span class="p">{</span>
  <span class="n">Variant</span> <span class="n">v</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">payload</span><span class="p">[];</span>
<span class="p">};</span>
</code></pre>
</div>

<p>So, our fast path <code class="highlighter-rouge">write</code> function will need to take a wrapper struct, switch on the tag, then call the appropriate version of <code class="highlighter-rouge">writeFields</code>:</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span> <span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">v</span> <span class="o">==</span> <span class="n">Variant</span><span class="o">::</span><span class="n">eA</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">writeFields</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">writeFields</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span><span class="p">(</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">B</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>
</code></pre>
</div>

<p>If <code class="highlighter-rouge">PADDING1 == PADDING2</code>, then, regardless of the value of the tag (which struct we are populating), we will need to write to the same offsets.
The cast and the templated function call will all compile out.
Take a look (<code class="highlighter-rouge">clang-4.0 --std=c++1z -O3</code>):</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="p">.</span><span class="n">LCPI2_0</span><span class="o">:</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">12</span>                      <span class="err">#</span> <span class="mh">0xc</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">25</span>                      <span class="err">#</span> <span class="mh">0x19</span>
<span class="n">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span><span class="p">)</span><span class="o">:</span>                      <span class="err">#</span> <span class="err">@</span><span class="n">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span><span class="p">)</span>
        <span class="n">movaps</span>  <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rip</span> <span class="o">+</span> <span class="p">.</span><span class="n">LCPI2_0</span><span class="err">]</span> <span class="err">#</span> <span class="n">xmm0</span> <span class="o">=</span> <span class="err">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">25</span><span class="err">]</span>
        <span class="n">movups</span>  <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="err">]</span><span class="p">,</span> <span class="n">xmm0</span>
        <span class="k">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">36</span><span class="err">]</span><span class="p">,</span> <span class="mi">16</span>
        <span class="k">ret</span>
</code></pre>
</div>

<p>Before we move on, take a moment to appreciate what your compiler just did for you:</p>
<ol>
  <li>It allowed you to write a type safe <code class="highlighter-rouge">writeFields</code> method. If the layout of the struct changes for some reason, this part of the code will not begin to misbehave.</li>
  <li>It removed the cost of the abstraction when it could figure out how to.</li>
</ol>

<p>Unfortunately, if <code class="highlighter-rouge">PADDING1 != PADDING2</code>, we will need to write the value of <code class="highlighter-rouge">c</code> in a different location in struct <code class="highlighter-rouge">A</code> and struct <code class="highlighter-rouge">B</code>.
In this case, it looks like we will need read the tag out of the <code class="highlighter-rouge">Wrapper*</code>, then branch to the appropriate <code class="highlighter-rouge">writeFields</code> method.
We are good programmers, we know that branches might be expensive, so we really want avoid any branching.</p>

<p>We can skip the branch by storing the offset in our wrapper struct and precomputing the offset when the wrapper is set up.
Introduce a new wrapper type (and abandon all type safety):</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">struct</span> <span class="n">WrapperWithOffset</span> <span class="p">{</span>
  <span class="n">Variant</span> <span class="n">v</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">offset</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">payload</span><span class="p">[];</span>
<span class="p">};</span>
</code></pre>
</div>

<p>Next, we can write a new function which will operate on structs of type <code class="highlighter-rouge">A</code> or type <code class="highlighter-rouge">B</code>, but, instead of writing to <code class="highlighter-rouge">c</code> directly, it computes a pointer to <code class="highlighter-rouge">c</code> using the offset we’ve stored in the wrapper, then writes to that pointer.</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">writeFieldsWithOffset</span><span class="p">(</span><span class="n">A</span><span class="o">*</span> <span class="n">t</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">c_offset</span><span class="p">)</span>
<span class="p">{</span>
  <span class="c1">// make sure a and b are always at the same offset in struct A and struct B
</span>  <span class="k">static_assert</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">a</span><span class="p">)</span> <span class="o">==</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">a</span><span class="p">),</span> <span class="s">"!"</span><span class="p">);</span>
  <span class="k">static_assert</span><span class="p">(</span><span class="n">offsetof</span><span class="p">(</span><span class="n">A</span><span class="p">,</span> <span class="n">b</span><span class="p">)</span> <span class="o">==</span> <span class="n">offsetof</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="s">"!"</span><span class="p">);</span>

  <span class="n">t</span><span class="o">-&gt;</span><span class="n">a</span> <span class="o">=</span> <span class="mi">12</span><span class="p">;</span>
  <span class="n">t</span><span class="o">-&gt;</span><span class="n">b</span> <span class="o">=</span> <span class="mi">25</span><span class="p">;</span>

  <span class="c1">// c will be at the offset we've provided
</span>  <span class="o">*</span><span class="p">(</span><span class="kt">int64_t</span><span class="o">*</span><span class="p">)(((</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">t</span> <span class="o">+</span> <span class="n">c_offset</span><span class="p">))</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">writeLessSafe</span><span class="p">(</span><span class="n">WrapperWithOffset</span><span class="o">*</span> <span class="n">w</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">A</span><span class="o">*</span> <span class="n">a</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">A</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">w</span><span class="o">-&gt;</span><span class="n">payload</span><span class="p">);</span>
  <span class="n">writeFieldsWithOffset</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">w</span><span class="o">-&gt;</span><span class="n">offset</span><span class="p">);</span>
<span class="p">}</span>
</code></pre>
</div>

<p>Checking the code, this compiles down to exactly what we were hoping it would (again with clang-4.0)!</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="p">.</span><span class="n">LCPI1_0</span><span class="o">:</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">12</span>                      <span class="err">#</span> <span class="mh">0xc</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">25</span>                      <span class="err">#</span> <span class="mh">0x19</span>
<span class="n">writeLessSafe</span><span class="p">(</span><span class="n">WrapperWithOffset</span><span class="o">*</span><span class="p">)</span><span class="o">:</span> <span class="err">#</span> <span class="err">@</span><span class="n">writeLessSafe</span><span class="p">(</span><span class="n">WrapperWithOffset</span><span class="o">*</span><span class="p">)</span>
        <span class="k">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">8</span><span class="err">]</span>
        <span class="n">movaps</span>  <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rip</span> <span class="o">+</span> <span class="p">.</span><span class="n">LCPI1_0</span><span class="err">]</span> <span class="err">#</span> <span class="n">xmm0</span> <span class="o">=</span> <span class="err">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">25</span><span class="err">]</span>
        <span class="n">movups</span>  <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">16</span><span class="err">]</span><span class="p">,</span> <span class="n">xmm0</span>
        <span class="k">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">rax</span> <span class="o">+</span> <span class="mi">16</span><span class="err">]</span><span class="p">,</span> <span class="mi">16</span>
        <span class="k">ret</span>
</code></pre>
</div>

<p>Hooray, no conditional generated, exactly as we desired.
We’ve outsmarted the compiler!</p>

<h4 id="assertion-failed-smarter_than_compiler">Assertion Failed: smarter_than_compiler</h4>

<p>Let’s set <code class="highlighter-rouge">PADDING1 = 16</code> and <code class="highlighter-rouge">PADDING2 = 17</code>.
The code generated on clang-4.0 for <code class="highlighter-rouge">write(Wrapper*)</code> looks quite interesting:</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="p">.</span><span class="n">LCPI2_0</span><span class="o">:</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">12</span>                      <span class="err">#</span> <span class="mh">0xc</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">25</span>                      <span class="err">#</span> <span class="mh">0x19</span>
<span class="n">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span><span class="p">)</span><span class="o">:</span>                      <span class="err">#</span> <span class="err">@</span><span class="n">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span><span class="p">)</span>
        <span class="k">xor</span>     <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="k">cmp</span>     <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[rdi],</span> <span class="mi">0</span>
        <span class="n">movaps</span>  <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rip</span> <span class="o">+</span> <span class="p">.</span><span class="n">LCPI2_0</span><span class="err">]</span> <span class="err">#</span> <span class="n">xmm0</span> <span class="o">=</span> <span class="err">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">25</span><span class="err">]</span>
        <span class="n">movups</span>  <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="err">]</span><span class="p">,</span> <span class="n">xmm0</span>
        <span class="k">setne</span>   <span class="n">al</span>
        <span class="k">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">rax</span> <span class="o">+</span> <span class="mi">36</span><span class="err">]</span><span class="p">,</span> <span class="mi">16</span>
        <span class="k">ret</span>
</code></pre>
</div>

<p>This code is still very slightly longer than the unsafe code written previously, but, its really not bad at all.</p>

<p>The compiler has succeeded in avoiding a branch using a rather clever <code class="highlighter-rouge">cmp</code> and <code class="highlighter-rouge">setne</code> instruction pair.
Essentially, clang figured out that it could compute the offset of <code class="highlighter-rouge">c</code> using the tag we’ve placed in the <code class="highlighter-rouge">Wrapper</code>’s <code class="highlighter-rouge">Variant</code> field.
In this case, I’ve allowed the enum values to default to <code class="highlighter-rouge">0</code> and <code class="highlighter-rouge">1</code> (hence the <code class="highlighter-rouge">cmp dword ptr [rdi], 0</code> checking if the first thing in the functions first arg is equal to 0).</p>

<p>What happens if we change the values?</p>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="k">enum</span> <span class="k">class</span> <span class="nc">Variant</span> <span class="p">{</span> <span class="n">eA</span> <span class="o">=</span> <span class="mi">666</span><span class="p">,</span> <span class="n">eB</span> <span class="o">=</span> <span class="mi">1337</span> <span class="p">};</span>
</code></pre>
</div>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="p">.</span><span class="n">LCPI2_0</span><span class="o">:</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">12</span>                      <span class="err">#</span> <span class="mh">0xc</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">25</span>                      <span class="err">#</span> <span class="mh">0x19</span>
<span class="n">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span><span class="p">)</span><span class="o">:</span>                      <span class="err">#</span> <span class="err">@</span><span class="n">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span><span class="p">)</span>
        <span class="k">mov</span>     <span class="n">eax</span><span class="p">,</span> <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[rdi]</span>
        <span class="n">movaps</span>  <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rip</span> <span class="o">+</span> <span class="p">.</span><span class="n">LCPI2_0</span><span class="err">]</span> <span class="err">#</span> <span class="n">xmm0</span> <span class="o">=</span> <span class="err">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">25</span><span class="err">]</span>
        <span class="n">movups</span>  <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="err">]</span><span class="p">,</span> <span class="n">xmm0</span>
        <span class="k">xor</span>     <span class="n">ecx</span><span class="p">,</span> <span class="n">ecx</span>
        <span class="k">cmp</span>     <span class="n">eax</span><span class="p">,</span> <span class="mi">666</span>
        <span class="k">setne</span>   <span class="n">cl</span>
        <span class="k">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">rcx</span> <span class="o">+</span> <span class="mi">36</span><span class="err">]</span><span class="p">,</span> <span class="mi">16</span>
        <span class="k">ret</span>
</code></pre>
</div>

<p>The code has changed slightly to account for the new potential values of <code class="highlighter-rouge">Wrapper::v</code>, but it looks much nicer than a branch.</p>

<h3 id="meaner-padding">Meaner PADDING</h3>
<p>Reminder: In the previous examples <code class="highlighter-rouge">PADDING1 = 16</code> and <code class="highlighter-rouge">PADDING2 = 17</code>.
What happens to the generated code if we make the paddings completely wacky?</p>

<p>With <code class="highlighter-rouge">PADDING1 = 16</code> and <code class="highlighter-rouge">PADDING2 = 173</code>, and with the enum values reverted to their defaults:</p>

<div class="language-nasm highlighter-rouge"><pre class="highlight"><code><span class="p">.</span><span class="n">LCPI1_0</span><span class="o">:</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">12</span>                      <span class="err">#</span> <span class="mh">0xc</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">25</span>                      <span class="err">#</span> <span class="mh">0x19</span>
<span class="n">writeLessSafe</span><span class="p">(</span><span class="n">WrapperWithOffset</span><span class="o">*</span><span class="p">)</span><span class="o">:</span> <span class="err">#</span> <span class="err">@</span><span class="n">writeLessSafe</span><span class="p">(</span><span class="n">WrapperWithOffset</span><span class="o">*</span><span class="p">)</span>
        <span class="k">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">qword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">8</span><span class="err">]</span>
        <span class="n">movaps</span>  <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rip</span> <span class="o">+</span> <span class="p">.</span><span class="n">LCPI1_0</span><span class="err">]</span> <span class="err">#</span> <span class="n">xmm0</span> <span class="o">=</span> <span class="err">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">25</span><span class="err">]</span>
        <span class="n">movups</span>  <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">16</span><span class="err">]</span><span class="p">,</span> <span class="n">xmm0</span>
        <span class="k">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">rax</span> <span class="o">+</span> <span class="mi">16</span><span class="err">]</span><span class="p">,</span> <span class="mi">16</span>
        <span class="k">ret</span>

<span class="p">.</span><span class="n">LCPI2_0</span><span class="o">:</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">12</span>                      <span class="err">#</span> <span class="mh">0xc</span>
        <span class="p">.</span><span class="n">quad</span>   <span class="mi">25</span>                      <span class="err">#</span> <span class="mh">0x19</span>
<span class="n">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span><span class="p">)</span><span class="o">:</span>                      <span class="err">#</span> <span class="err">@</span><span class="n">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span><span class="p">)</span>
        <span class="k">cmp</span>     <span class="n">dword</span> <span class="n">ptr</span> <span class="p">[rdi],</span> <span class="mi">0</span>
        <span class="n">movaps</span>  <span class="n">xmm0</span><span class="p">,</span> <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rip</span> <span class="o">+</span> <span class="p">.</span><span class="n">LCPI2_0</span><span class="err">]</span> <span class="err">#</span> <span class="n">xmm0</span> <span class="o">=</span> <span class="err">[</span><span class="mi">12</span><span class="p">,</span><span class="mi">25</span><span class="err">]</span>
        <span class="n">movups</span>  <span class="n">xmmword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="mi">4</span><span class="err">]</span><span class="p">,</span> <span class="n">xmm0</span>
        <span class="k">mov</span>     <span class="n">eax</span><span class="p">,</span> <span class="mi">32</span>
        <span class="k">mov</span>     <span class="n">ecx</span><span class="p">,</span> <span class="mi">189</span>
        <span class="k">cmove</span>   <span class="n">rcx</span><span class="p">,</span> <span class="n">rax</span>
        <span class="k">mov</span>     <span class="n">qword</span> <span class="n">ptr</span> <span class="err">[</span><span class="n">rdi</span> <span class="o">+</span> <span class="n">rcx</span> <span class="o">+</span> <span class="mi">4</span><span class="err">]</span><span class="p">,</span> <span class="mi">16</span>
        <span class="k">ret</span>
</code></pre>
</div>

<p><code class="highlighter-rouge">writeLessSafe</code> doesn’t change, as expected.
<code class="highlighter-rouge">write</code> does get tweaked a bit to account for the new offsets, but its still pretty great code.</p>

<p>So, have we beaten the compiler?
The answer to that depends on which compiler you ask.</p>

<h3 id="gcc-71-stdc1z--o3">gcc 7.1 (–std=c++1z -O3)</h3>
<h4 id="padding1--padding2"><code class="highlighter-rouge">PADDING1</code> == <code class="highlighter-rouge">PADDING2</code></h4>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">writeLessSafe</span><span class="p">(</span><span class="n">WrapperWithOffset</span><span class="o">*</span><span class="p">)</span><span class="o">:</span>
        <span class="n">mov</span>     <span class="n">rax</span><span class="p">,</span> <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">8</span><span class="p">]</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">16</span><span class="p">],</span> <span class="mi">12</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">24</span><span class="p">],</span> <span class="mi">25</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">16</span><span class="o">+</span><span class="n">rax</span><span class="p">],</span> <span class="mi">16</span>
        <span class="n">ret</span>
<span class="n">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span><span class="p">)</span><span class="o">:</span>
        <span class="n">mov</span>     <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="p">]</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="mi">12</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">12</span><span class="p">],</span> <span class="mi">25</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">36</span><span class="p">],</span> <span class="mi">16</span>
        <span class="n">test</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="n">je</span>      <span class="p">.</span><span class="n">L7</span>
        <span class="n">rep</span> <span class="n">ret</span>
<span class="p">.</span><span class="n">L7</span><span class="o">:</span>
        <span class="n">rep</span> <span class="n">ret</span>
</code></pre>
</div>

<p>That’s a little odd.</p>

<h4 id="padding1--16-and-padding2--17"><code class="highlighter-rouge">PADDING1 = 16</code> and <code class="highlighter-rouge">PADDING2 = 17</code></h4>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span><span class="p">)</span><span class="o">:</span>
        <span class="n">mov</span>     <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="p">]</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="mi">12</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">12</span><span class="p">],</span> <span class="mi">25</span>
        <span class="n">test</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="n">je</span>      <span class="p">.</span><span class="n">L7</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">37</span><span class="p">],</span> <span class="mi">16</span>
        <span class="n">ret</span>
<span class="p">.</span><span class="n">L7</span><span class="o">:</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">36</span><span class="p">],</span> <span class="mi">16</span>
        <span class="n">ret</span>
</code></pre>
</div>

<h4 id="padding1--16-and-padding2--173"><code class="highlighter-rouge">PADDING1 = 16</code> and <code class="highlighter-rouge">PADDING2 = 173</code></h4>

<div class="language-c++ highlighter-rouge"><pre class="highlight"><code><span class="n">write</span><span class="p">(</span><span class="n">Wrapper</span><span class="o">*</span><span class="p">)</span><span class="o">:</span>
        <span class="n">mov</span>     <span class="n">eax</span><span class="p">,</span> <span class="n">DWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="p">]</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">4</span><span class="p">],</span> <span class="mi">12</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">12</span><span class="p">],</span> <span class="mi">25</span>
        <span class="n">test</span>    <span class="n">eax</span><span class="p">,</span> <span class="n">eax</span>
        <span class="n">je</span>      <span class="p">.</span><span class="n">L7</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">193</span><span class="p">],</span> <span class="mi">16</span>
        <span class="n">ret</span>
<span class="p">.</span><span class="n">L7</span><span class="o">:</span>
        <span class="n">mov</span>     <span class="n">QWORD</span> <span class="n">PTR</span> <span class="p">[</span><span class="n">rdi</span><span class="o">+</span><span class="mi">36</span><span class="p">],</span> <span class="mi">16</span>
        <span class="n">ret</span>
</code></pre>
</div>

<p>Interesting.
This branch felt <em>almost</em> detectable in some micro-benchmarks, but I would require additional testing before I’m willing to declare that it is harmful.
At the moment I’m not convinced that it hurts much.</p>

<h3 id="conclusion">Conclusion</h3>
<p>No conclusion.
None of my benchmarks have managed to detect any convincing cost for this branch (even when variants are randomly chosen inside of a loop in an attempt to confuse branch predictor) so none of this actually matters (probably).
The only interesting fact my benchmarks showed is that clang 4.0 looked very very slightly faster than gcc 6.3, possibly because of the vector instructions clang is generating, but also possibly because benchmarking is hard and I’m not benchmarking on isolated cores.
Here’s some code: <a href="https://gist.github.com/dpzmick/a8f937c5e35185092b6af9a5ed87a7b8">gist</a>.</p>

</article>







      </div>
    </div>
  </div>

  <footer class="footer">
  <div class="p2 wrap">
    <div class="measure mt1 center">
      <small>
        Theme crafted with &lt;3 by <a href="http://johnotander.com">John Otander</a> (<a href="https://twitter.com/4lpine">@4lpine</a>).<br>
      </small>
    </div>
  </div>
</footer>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','//www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-40842690-1', 'auto');
ga('send', 'pageview');

</script>


<script type="text/javascript"
        src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

</body>
</html>
